// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Objects argNamedQuery.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\"
    type raw_t
    type t = < argNamedQuery: int   >  Js.t
    type t_variables = < query: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             argNamedQuery =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"argNamedQuery\\" in
                (Obj.magic value : int))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"query\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## query)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~query  () =
      f (serializeVariables ([%bs.obj { query }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects comment.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < nonrecursiveInput: string   >  Js.t
    type t_variables = < arg: t_variables_NonrecursiveInput   >  Js.t
    and t_variables_NonrecursiveInput =
      < field: string option  ;enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option  
        >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             nonrecursiveInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"nonrecursiveInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectNonrecursiveInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectNonrecursiveInput :
      t_variables_NonrecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"field\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## field)));
             (\\"enum\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                ((match a with
                                  | \`FIRST -> Js.Json.string \\"FIRST\\"
                                  | \`SECOND -> Js.Json.string \\"SECOND\\"
                                  | \`THIRD -> Js.Json.string \\"THIRD\\")))
                            [@explicit_arity ]))) b)) (inp ## enum)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectNonrecursiveInput ?field  ?enum  () =
      ([%bs.obj { field; enum }] : t_variables_NonrecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects customDecoder.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module StringOfInt = struct let parse = string_of_int
                            type t = string end
module IntOfString = struct let parse = int_of_string
                            type t = int end
module MyQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < variousScalars: t_variousScalars   >  Js.t
    and t_variousScalars =
      < string: IntOfString.t  ;int: StringOfInt.t   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             variousScalars =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       IntOfString.parse (Obj.magic value : string));
                    int =
                      (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                       StringOfInt.parse (Obj.magic value : int))
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects customScalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < customScalarField: t_customScalarField   >  Js.t
    and t_customScalarField =
      < nullable: Js.Json.t option  ;nonNullable: Js.Json.t   >  Js.t
    type t_variables = < opt: Js.Json.t option  ;req: Js.Json.t   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             customScalarField =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"customScalarField\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullable\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some (value))[@explicit_arity ])
                       | None -> None);
                    nonNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nonNullable\\" in
                       value)
                  }])
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"opt\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some (a))[@explicit_arity ]))) b))
                  (inp ## opt)));(\\"req\\",
                                   (((fun a -> ((Some (a))[@explicit_arity ])))
                                      (inp ## req)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?opt  ~req  () =
      f (serializeVariables ([%bs.obj { opt; req }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects enumInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < enumInput: string   >  Js.t
    type t_variables = < arg: [ \`FIRST  | \`SECOND  | \`THIRD ]   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             enumInput =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"enumInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some
                        ((match a with
                          | \`FIRST -> Js.Json.string \\"FIRST\\"
                          | \`SECOND -> Js.Json.string \\"SECOND\\"
                          | \`THIRD -> Js.Json.string \\"THIRD\\")))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects fragmentDefinition.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module Fragments =
  struct
    let query =
      \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\"
    type t =
      <
        nullableOfNullable: string option array option  ;nullableOfNonNullable: 
                                                           string array
                                                             option   > 
        Js.t
    type raw_t
    type t_Lists = t
    let parse (value : Js.Json.t) =
      let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
        [@@metaloc loc] in
      [%bs.obj
        {
          nullableOfNullable =
            (let value =
               Js.Dict.unsafeGet (Obj.magic value) \\"nullableOfNullable\\" in
             match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
             | Some _ ->
                 ((Some
                     (((Obj.magic value) |>
                         (Js.Array.map
                            (fun value ->
                               match Js.toOption
                                       (Obj.magic value : 'a Js.Nullable.t)
                               with
                               | Some _ ->
                                   ((Some ((Obj.magic value : string)))
                                   [@explicit_arity ])
                               | None -> None)))))
                 [@explicit_arity ])
             | None -> None);
          nullableOfNonNullable =
            (let value =
               Js.Dict.unsafeGet (Obj.magic value) \\"nullableOfNonNullable\\" in
             match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
             | Some _ ->
                 ((Some
                     (((Obj.magic value) |>
                         (Js.Array.map
                            (fun value -> (Obj.magic value : string))))))
                 [@explicit_arity ])
             | None -> None)
        }]
    let name = \\"ListFragment\\"
  end
module MyQuery =
  struct
    let query =
      ((((((\\"query   {\\\\nl1: lists  {\\\\n...\\" ^ Fragments.ListFragment.name) ^
             \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\")
            ^ Fragments.ListFragment.name)
           ^ \\"   \\\\n...\\")
          ^ Fragments.ListFragment.name)
         ^ \\"   \\\\n}\\\\n\\\\n}\\\\n\\")
        ^ Fragments.ListFragment.query
    type raw_t
    type t = < l1: Fragments.ListFragment.t  ;l2: t_l2   >  Js.t
    and t_l2 =
      <
        frag1: Fragments.ListFragment.t_Lists  ;frag2: Fragments.ListFragment.t_Lists
                                                    > 
        Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             l1 =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"l1\\" in
                Fragments.ListFragment.parse value);
             l2 =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"l2\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    frag1 = (Fragments.ListFragment.parse value);
                    frag2 = (Fragments.ListFragment.parse value)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects interface.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module QueryWithFragments =
  struct
    let query =
      \\"query   {\\\\nusers  {\\\\n__typename\\\\nid  \\\\n...on AdminUser   {\\\\nname  \\\\n}\\\\n\\\\n...on AnonymousUser   {\\\\nanonymousId  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      <
        users: [ \`User of t_users_User 
               | \`AnonymousUser of t_users_AnonymousUser 
               | \`AdminUser of t_users_AdminUser ] array   > 
        Js.t
    and t_users_AdminUser = < id: string  ;name: string   >  Js.t
    and t_users_AnonymousUser = < id: string  ;anonymousId: int   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             users =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"users\\" in
                (Obj.magic value) |>
                  (Js.Array.map
                     (fun value ->
                        match Js.Json.decodeObject value with
                        | None ->
                            Js.Exn.raiseError
                              (\\"graphql_ppx: \\" ^
                                 (\\"Expected Interface implementation \\" ^
                                    (\\"User\\" ^
                                       (\\" to be an object, got \\" ^
                                          (Js.Json.stringify value)))))
                        | ((Some (typename_obj))[@explicit_arity ]) ->
                            (match Js.Dict.get typename_obj \\"__typename\\" with
                             | None ->
                                 Js.Exn.raiseError
                                   (\\"graphql_ppx: \\" ^
                                      (\\"Interface implementation\\" ^
                                         (\\"User\\" ^
                                            \\" is missing the __typename field\\")))
                             | ((Some (typename))[@explicit_arity ]) ->
                                 (match Js.Json.decodeString typename with
                                  | None ->
                                      Js.Exn.raiseError
                                        (\\"graphql_ppx: \\" ^
                                           (\\"Interface implementation \\" ^
                                              (\\"User\\" ^
                                                 \\" has a __typename field that is not a string\\")))
                                  | ((Some (typename))[@explicit_arity ]) ->
                                      ((match typename with
                                        | \\"AnonymousUser\\" ->
                                            \`AnonymousUser
                                              (let value =
                                                 (value |>
                                                    Js.Json.decodeObject)
                                                   |> Js.Option.getExn
                                                 [@@metaloc loc] in
                                               [%bs.obj
                                                 {
                                                   id =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"id\\" in
                                                      (Obj.magic value : 
                                                        string));
                                                   anonymousId =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"anonymousId\\" in
                                                      (Obj.magic value : 
                                                        int))
                                                 }])
                                        | \\"AdminUser\\" ->
                                            \`AdminUser
                                              (let value =
                                                 (value |>
                                                    Js.Json.decodeObject)
                                                   |> Js.Option.getExn
                                                 [@@metaloc loc] in
                                               [%bs.obj
                                                 {
                                                   id =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"id\\" in
                                                      (Obj.magic value : 
                                                        string));
                                                   name =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"name\\" in
                                                      (Obj.magic value : 
                                                        string))
                                                 }])
                                        | _ ->
                                            \`User
                                              (let value =
                                                 (value |>
                                                    Js.Json.decodeObject)
                                                   |> Js.Option.getExn
                                                 [@@metaloc loc] in
                                               [%bs.obj
                                                 {
                                                   id =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"id\\" in
                                                      (Obj.magic value : 
                                                        string))
                                                 }])) : [ \`User of _ 
                                                        | \`AnonymousUser of _ 
                                                        | \`AdminUser of _ ]))))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module QueryWithoutFragments =
  struct
    let query = \\"query   {\\\\nusers  {\\\\n__typename\\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < users: [ \`User of t_users_User ] array   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             users =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"users\\" in
                (Obj.magic value) |>
                  (Js.Array.map
                     (fun value ->
                        match Js.Json.decodeObject value with
                        | None ->
                            Js.Exn.raiseError
                              (\\"graphql_ppx: \\" ^
                                 (\\"Expected Interface implementation \\" ^
                                    (\\"User\\" ^
                                       (\\" to be an object, got \\" ^
                                          (Js.Json.stringify value)))))
                        | ((Some (typename_obj))[@explicit_arity ]) ->
                            (match Js.Dict.get typename_obj \\"__typename\\" with
                             | None ->
                                 Js.Exn.raiseError
                                   (\\"graphql_ppx: \\" ^
                                      (\\"Interface implementation\\" ^
                                         (\\"User\\" ^
                                            \\" is missing the __typename field\\")))
                             | ((Some (typename))[@explicit_arity ]) ->
                                 (match Js.Json.decodeString typename with
                                  | None ->
                                      Js.Exn.raiseError
                                        (\\"graphql_ppx: \\" ^
                                           (\\"Interface implementation \\" ^
                                              (\\"User\\" ^
                                                 \\" has a __typename field that is not a string\\")))
                                  | ((Some (typename))[@explicit_arity ]) ->
                                      ((match typename with
                                        | _ ->
                                            \`User
                                              (let value =
                                                 (value |>
                                                    Js.Json.decodeObject)
                                                   |> Js.Option.getExn
                                                 [@@metaloc loc] in
                                               [%bs.obj
                                                 {
                                                   id =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"id\\" in
                                                      (Obj.magic value : 
                                                        string))
                                                 }])) : [ \`User of _ ]))))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects lists.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < lists: t_lists   >  Js.t
    and t_lists =
      <
        nullableOfNullable: string option array option  ;nullableOfNonNullable: 
                                                           string array
                                                             option  ;
        nonNullableOfNullable: string option array  ;nonNullableOfNonNullable: 
                                                       string array   > 
        Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             lists =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"lists\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableOfNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nullableOfNullable\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               (((Obj.magic value) |>
                                   (Js.Array.map
                                      (fun value ->
                                         match Js.toOption
                                                 (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                         with
                                         | Some _ ->
                                             ((Some
                                                 ((Obj.magic value : string)))
                                             [@explicit_arity ])
                                         | None -> None)))))
                           [@explicit_arity ])
                       | None -> None);
                    nullableOfNonNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nullableOfNonNullable\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               (((Obj.magic value) |>
                                   (Js.Array.map
                                      (fun value ->
                                         (Obj.magic value : string))))))
                           [@explicit_arity ])
                       | None -> None);
                    nonNullableOfNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nonNullableOfNullable\\" in
                       (Obj.magic value) |>
                         (Js.Array.map
                            (fun value ->
                               match Js.toOption
                                       (Obj.magic value : 'a Js.Nullable.t)
                               with
                               | Some _ ->
                                   ((Some ((Obj.magic value : string)))
                                   [@explicit_arity ])
                               | None -> None)));
                    nonNullableOfNonNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nonNullableOfNonNullable\\" in
                       (Obj.magic value) |>
                         (Js.Array.map
                            (fun value -> (Obj.magic value : string))))
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects listsArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\"
    type raw_t
    type t = < listsInput: string   >  Js.t
    type t_variables =
      <
        nullableOfNullable: string option array option  ;nullableOfNonNullable: 
                                                           string array
                                                             option  ;
        nonNullableOfNullable: string option array  ;nonNullableOfNonNullable: 
                                                       string array   > 
        Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             listsInput =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"listsInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableOfNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    match a with
                                                    | None -> None
                                                    | ((Some
                                                        (b))[@explicit_arity
                                                              ])
                                                        ->
                                                        ((fun a ->
                                                            ((Some
                                                                ((Js.Json.string
                                                                    a)))
                                                            [@explicit_arity
                                                              ]))) b) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b))
                  (inp ## nullableOfNullable)));(\\"nullableOfNonNullable\\",
                                                  (((fun a ->
                                                       match a with
                                                       | None -> None
                                                       | ((Some
                                                           (b))[@explicit_arity
                                                                 ])
                                                           ->
                                                           ((fun a ->
                                                               ((Some
                                                                   (((a |>
                                                                    (Array.map
                                                                    (fun b ->
                                                                    match 
                                                                    (fun a ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ])) b
                                                                    with
                                                                    | 
                                                                    ((Some
                                                                    (c))
                                                                    [@explicit_arity
                                                                    ]) -> c
                                                                    | 
                                                                    None ->
                                                                    Js.Json.null)))
                                                                    |>
                                                                    Js.Json.array)))
                                                               [@explicit_arity
                                                                 ]))) b))
                                                     (inp ##
                                                        nullableOfNonNullable)));
             (\\"nonNullableOfNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            match a with
                                            | None -> None
                                            | ((Some (b))[@explicit_arity ])
                                                ->
                                                ((fun a ->
                                                    ((Some
                                                        ((Js.Json.string a)))
                                                    [@explicit_arity ]))) b)
                                           b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) (inp ## nonNullableOfNullable)));
             (\\"nonNullableOfNonNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            ((Some ((Js.Json.string a)))
                                            [@explicit_arity ])) b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) (inp ## nonNullableOfNonNullable)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?nullableOfNullable  ?nullableOfNonNullable 
      ~nonNullableOfNullable  ~nonNullableOfNonNullable  () =
      f
        (serializeVariables
           ([%bs.obj
              {
                nullableOfNullable;
                nullableOfNonNullable;
                nonNullableOfNullable;
                nonNullableOfNonNullable
              }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects listsInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < listsInput: string   >  Js.t
    type t_variables = < arg: t_variables_ListsInput   >  Js.t
    and t_variables_ListsInput =
      <
        nullableOfNullable: string option array option  ;nullableOfNonNullable: 
                                                           string array
                                                             option  ;
        nonNullableOfNullable: string option array  ;nonNullableOfNonNullable: 
                                                       string array   > 
        Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             listsInput =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"listsInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a -> ((Some ((serializeInputObjectListsInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectListsInput :
      t_variables_ListsInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableOfNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    match a with
                                                    | None -> None
                                                    | ((Some
                                                        (b))[@explicit_arity
                                                              ])
                                                        ->
                                                        ((fun a ->
                                                            ((Some
                                                                ((Js.Json.string
                                                                    a)))
                                                            [@explicit_arity
                                                              ]))) b) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b))
                  (inp ## nullableOfNullable)));(\\"nullableOfNonNullable\\",
                                                  (((fun a ->
                                                       match a with
                                                       | None -> None
                                                       | ((Some
                                                           (b))[@explicit_arity
                                                                 ])
                                                           ->
                                                           ((fun a ->
                                                               ((Some
                                                                   (((a |>
                                                                    (Array.map
                                                                    (fun b ->
                                                                    match 
                                                                    (fun a ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ])) b
                                                                    with
                                                                    | 
                                                                    ((Some
                                                                    (c))
                                                                    [@explicit_arity
                                                                    ]) -> c
                                                                    | 
                                                                    None ->
                                                                    Js.Json.null)))
                                                                    |>
                                                                    Js.Json.array)))
                                                               [@explicit_arity
                                                                 ]))) b))
                                                     (inp ##
                                                        nullableOfNonNullable)));
             (\\"nonNullableOfNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            match a with
                                            | None -> None
                                            | ((Some (b))[@explicit_arity ])
                                                ->
                                                ((fun a ->
                                                    ((Some
                                                        ((Js.Json.string a)))
                                                    [@explicit_arity ]))) b)
                                           b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) (inp ## nonNullableOfNullable)));
             (\\"nonNullableOfNonNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            ((Some ((Js.Json.string a)))
                                            [@explicit_arity ])) b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) (inp ## nonNullableOfNonNullable)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectListsInput ?nullableOfNullable  ?nullableOfNonNullable
       ~nonNullableOfNullable  ~nonNullableOfNonNullable  () =
      ([%bs.obj
         {
           nullableOfNullable;
           nullableOfNonNullable;
           nonNullableOfNullable;
           nonNullableOfNonNullable
         }] : t_variables_ListsInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects mutation.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < mutationWithError: t_mutationWithError   >  Js.t
    and t_mutationWithError =
      <
        value: t_mutationWithError_value option  ;errors: t_mutationWithError_errors
                                                            array option   > 
        Js.t
    and t_mutationWithError_errors =
      < field: [ \`FIRST  | \`SECOND  | \`THIRD ]  ;message: string   >  Js.t
    and t_mutationWithError_value = < stringField: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             mutationWithError =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"mutationWithError\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    value =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"value\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               ((let value =
                                   (value |> Js.Json.decodeObject) |>
                                     Js.Option.getExn[@@metaloc loc] in
                                 [%bs.obj
                                   {
                                     stringField =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"stringField\\" in
                                        (Obj.magic value : string))
                                   }])))
                           [@explicit_arity ])
                       | None -> None);
                    errors =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"errors\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               (((Obj.magic value) |>
                                   (Js.Array.map
                                      (fun value ->
                                         let value =
                                           (value |> Js.Json.decodeObject) |>
                                             Js.Option.getExn[@@metaloc loc] in
                                         [%bs.obj
                                           {
                                             field =
                                               (let value =
                                                  Js.Dict.unsafeGet
                                                    (Obj.magic value) \\"field\\" in
                                                match Js.Json.decodeString
                                                        value
                                                with
                                                | None ->
                                                    Js.Exn.raiseError
                                                      (\\"graphql_ppx: \\" ^
                                                         (\\"Expected enum value for \\"
                                                            ^
                                                            (\\"SampleField\\" ^
                                                               (\\", got \\" ^
                                                                  (Js.Json.stringify
                                                                    value)))))
                                                | ((Some
                                                    (value))[@explicit_arity
                                                              ])
                                                    ->
                                                    ((match value with
                                                      | \\"FIRST\\" -> \`FIRST
                                                      | \\"SECOND\\" -> \`SECOND
                                                      | \\"THIRD\\" -> \`THIRD
                                                      | _ ->
                                                          Js.Exn.raiseError
                                                            (\\"graphql_ppx: \\"
                                                               ^
                                                               (\\"Unknown enum variant for \\"
                                                                  ^
                                                                  (\\"SampleField\\"
                                                                    ^
                                                                    (\\": \\" ^
                                                                    value))))) : 
                                                    [ \`FIRST  | \`SECOND 
                                                    | \`THIRD ]));
                                             message =
                                               (let value =
                                                  Js.Dict.unsafeGet
                                                    (Obj.magic value)
                                                    \\"message\\" in
                                                (Obj.magic value : string))
                                           }])))))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects mutationWithArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\"
    type raw_t
    type t = < optionalInputArgs: string   >  Js.t
    type t_variables = < required: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             optionalInputArgs =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"optionalInputArgs\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"required\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## required)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~required  () =
      f (serializeVariables ([%bs.obj { required }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects nested.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
type record = {
  f1: string ;
  f2: string }
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < first: t_first  ;second: t_second   >  Js.t
    and t_second = < inner: t_second_inner option   >  Js.t
    and t_second_inner = < inner: t_second_inner_inner option   >  Js.t
    and t_second_inner_inner = {
      f1: string ;
      f2: string }
    and t_first = < inner: t_first_inner option   >  Js.t
    and t_first_inner = < inner: t_first_inner_inner option   >  Js.t
    and t_first_inner_inner = < field: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             first =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"first\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    inner =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               ((let value =
                                   (value |> Js.Json.decodeObject) |>
                                     Js.Option.getExn[@@metaloc loc] in
                                 [%bs.obj
                                   {
                                     inner =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"inner\\" in
                                        (match Js.toOption
                                                 (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                         with
                                         | Some _ ->
                                             ((Some
                                                 ((let value =
                                                     (value |>
                                                        Js.Json.decodeObject)
                                                       |> Js.Option.getExn
                                                     [@@metaloc loc] in
                                                   [%bs.obj
                                                     {
                                                       field =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value)
                                                              \\"field\\" in
                                                          (Obj.magic value : 
                                                            string))
                                                     }])))
                                             [@explicit_arity ])
                                         | None -> None))
                                   }])))
                           [@explicit_arity ])
                       | None -> None)
                  }]);
             second =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"second\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    inner =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               ((let value =
                                   (value |> Js.Json.decodeObject) |>
                                     Js.Option.getExn[@@metaloc loc] in
                                 [%bs.obj
                                   {
                                     inner =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"inner\\" in
                                        (match Js.toOption
                                                 (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                         with
                                         | Some _ ->
                                             ((Some
                                                 ((let value =
                                                     (value |>
                                                        Js.Json.decodeObject)
                                                       |> Js.Option.getExn
                                                     [@@metaloc loc] in
                                                   [%bs.obj
                                                     {
                                                       f1 =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value) \\"f1\\" in
                                                          (Obj.magic value : 
                                                            string));
                                                       f2 =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value) \\"f2\\" in
                                                          (Obj.magic value : 
                                                            string))
                                                     }])))
                                             [@explicit_arity ])
                                         | None -> None))
                                   }])))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects nonrecursiveInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < nonrecursiveInput: string   >  Js.t
    type t_variables = < arg: t_variables_NonrecursiveInput   >  Js.t
    and t_variables_NonrecursiveInput =
      < field: string option  ;enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option  
        >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             nonrecursiveInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"nonrecursiveInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectNonrecursiveInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectNonrecursiveInput :
      t_variables_NonrecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"field\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## field)));
             (\\"enum\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                ((match a with
                                  | \`FIRST -> Js.Json.string \\"FIRST\\"
                                  | \`SECOND -> Js.Json.string \\"SECOND\\"
                                  | \`THIRD -> Js.Json.string \\"THIRD\\")))
                            [@explicit_arity ]))) b)) (inp ## enum)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectNonrecursiveInput ?field  ?enum  () =
      ([%bs.obj { field; enum }] : t_variables_NonrecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects pokedexApolloMode.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < pokemon: t_pokemon option   >  Js.t
    and t_pokemon = < id: string  ;name: string option   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             pokemon =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"pokemon\\" in
                match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
                | Some _ ->
                    ((Some
                        ((let value =
                            (value |> Js.Json.decodeObject) |>
                              Js.Option.getExn[@@metaloc loc] in
                          [%bs.obj
                            {
                              id =
                                (let value =
                                   Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                                 (Obj.magic value : string));
                              name =
                                (let value =
                                   Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                                 (match Js.toOption
                                          (Obj.magic value : 'a Js.Nullable.t)
                                  with
                                  | Some _ ->
                                      ((Some ((Obj.magic value : string)))
                                      [@explicit_arity ])
                                  | None -> None))
                            }])))
                    [@explicit_arity ])
                | None -> None)
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects pokedexScalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < pokemon: t_pokemon option   >  Js.t
    and t_pokemon = < id: string  ;name: string option   >  Js.t
    type t_variables = < id: string option  ;name: string option   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             pokemon =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"pokemon\\" in
                match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
                | Some _ ->
                    ((Some
                        ((let value =
                            (value |> Js.Json.decodeObject) |>
                              Js.Option.getExn[@@metaloc loc] in
                          [%bs.obj
                            {
                              id =
                                (let value =
                                   Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                                 (Obj.magic value : string));
                              name =
                                (let value =
                                   Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                                 (match Js.toOption
                                          (Obj.magic value : 'a Js.Nullable.t)
                                  with
                                  | Some _ ->
                                      ((Some ((Obj.magic value : string)))
                                      [@explicit_arity ])
                                  | None -> None))
                            }])))
                    [@explicit_arity ])
                | None -> None)
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"id\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## id)));(\\"name\\",
                                                                    (((fun a
                                                                    ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    (inp ##
                                                                    name)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?id  ?name  () =
      f (serializeVariables ([%bs.obj { id; name }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects record.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
type scalars = {
  string: string ;
  int: int }
type dog = {
  name: string ;
  barkVolume: float }
type oneFieldQuery = {
  nullableString: string option }
module MyQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < variousScalars: t_variousScalars   >  Js.t
    and t_variousScalars = {
      string: string ;
      int: int }
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             variousScalars =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       (Obj.magic value : string));
                    int =
                      (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                       (Obj.magic value : int))
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module OneFieldQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < variousScalars: t_variousScalars   >  Js.t
    and t_variousScalars = {
      nullableString: string option }
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             variousScalars =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableString =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module ExternalFragmentQuery =
  struct
    module Fragment =
      struct
        let query =
          \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\"
        type t = {
          string: string ;
          int: int }
        type raw_t
        type t_VariousScalars = t
        let parse (value : Js.Json.t) =
          let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
            [@@metaloc loc] in
          [%bs.obj
            {
              string =
                (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                 (Obj.magic value : string));
              int =
                (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                 (Obj.magic value : int))
            }]
        let name = \\"Fragment\\"
      end
    module Untitled1 =
      struct
        let query =
          ((\\"query   {\\\\nvariousScalars  {\\\\n...\\" ^ Fragment.name) ^
             \\"   \\\\n}\\\\n\\\\n}\\\\n\\")
            ^ Fragment.query
        type raw_t
        type t = < variousScalars: Fragment.t   >  Js.t
        let parse =
          (fun value ->
             let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
               [@@metaloc loc] in
             [%bs.obj
               {
                 variousScalars =
                   (let value =
                      Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                    Fragment.parse value)
               }] : Js.Json.t -> t)
        let makeVar ~f  () = f Js.Json.null
        let definition = (parse, query, makeVar)
      end
  end
module InlineFragmentQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      < dogOrHuman: [ \`Nonexhaustive  | \`Dog of t_dogOrHuman_Dog ]   >  Js.t
    and t_dogOrHuman_Dog = {
      name: string ;
      barkVolume: float }
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             dogOrHuman =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                match Js.Json.decodeObject value with
                | None ->
                    Js.Exn.raiseError
                      (\\"graphql_ppx: \\" ^
                         (\\"Expected union \\" ^
                            (\\"DogOrHuman\\" ^
                               (\\" to be an object, got \\" ^
                                  (Js.Json.stringify value)))))
                | ((Some (typename_obj))[@explicit_arity ]) ->
                    (match Js.Dict.get typename_obj \\"__typename\\" with
                     | None ->
                         Js.Exn.raiseError
                           (\\"graphql_ppx: \\" ^
                              (\\"Union \\" ^
                                 (\\"DogOrHuman\\" ^
                                    \\" is missing the __typename field\\")))
                     | ((Some (typename))[@explicit_arity ]) ->
                         (match Js.Json.decodeString typename with
                          | None ->
                              Js.Exn.raiseError
                                (\\"graphql_ppx: \\" ^
                                   (\\"Union \\" ^
                                      (\\"DogOrHuman\\" ^
                                         \\" has a __typename field that is not a string\\")))
                          | ((Some (typename))[@explicit_arity ]) ->
                              ((match typename with
                                | \\"Dog\\" ->
                                    \`Dog
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string));
                                           barkVolume =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value)
                                                  \\"barkVolume\\" in
                                              (Obj.magic value : float))
                                         }])
                                | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                         | \`Dog of _ ]))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module UnionExternalFragmentQuery =
  struct
    module DogFragment =
      struct
        let query =
          \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\"
        type t = {
          name: string ;
          barkVolume: float }
        type raw_t
        type t_Dog = t
        let parse (value : Js.Json.t) =
          let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
            [@@metaloc loc] in
          [%bs.obj
            {
              name =
                (let value = Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                 (Obj.magic value : string));
              barkVolume =
                (let value = Js.Dict.unsafeGet (Obj.magic value) \\"barkVolume\\" in
                 (Obj.magic value : float))
            }]
        let name = \\"DogFragment\\"
      end
    module Untitled1 =
      struct
        let query =
          ((\\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\" ^
              DogFragment.name)
             ^ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\")
            ^ DogFragment.query
        type raw_t
        type t =
          < dogOrHuman: [ \`Nonexhaustive  | \`Dog of DogFragment.t ]   >  Js.t
        let parse =
          (fun value ->
             let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
               [@@metaloc loc] in
             [%bs.obj
               {
                 dogOrHuman =
                   (let value =
                      Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                    match Js.Json.decodeObject value with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Expected union \\" ^
                                (\\"DogOrHuman\\" ^
                                   (\\" to be an object, got \\" ^
                                      (Js.Json.stringify value)))))
                    | ((Some (typename_obj))[@explicit_arity ]) ->
                        (match Js.Dict.get typename_obj \\"__typename\\" with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" is missing the __typename field\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             (match Js.Json.decodeString typename with
                              | None ->
                                  Js.Exn.raiseError
                                    (\\"graphql_ppx: \\" ^
                                       (\\"Union \\" ^
                                          (\\"DogOrHuman\\" ^
                                             \\" has a __typename field that is not a string\\")))
                              | ((Some (typename))[@explicit_arity ]) ->
                                  ((match typename with
                                    | \\"Dog\\" -> \`Dog (DogFragment.parse value)
                                    | _ -> \`Nonexhaustive) : [
                                                               \`Nonexhaustive 
                                                             | \`Dog of _ ]))))
               }] : Js.Json.t -> t)
        let makeVar ~f  () = f Js.Json.null
        let definition = (parse, query, makeVar)
      end
  end"
`;

exports[`Objects recursiveInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < recursiveInput: string   >  Js.t
    type t_variables = < arg: t_variables_RecursiveInput   >  Js.t
    and t_variables_RecursiveInput =
      <
        otherField: string option  ;inner: t_variables_RecursiveInput option  ;
        enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             recursiveInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"recursiveInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a -> ((Some ((serializeInputObjectRecursiveInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectRecursiveInput :
      t_variables_RecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"otherField\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## otherField)));
             (\\"inner\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some ((serializeInputObjectRecursiveInput a)))
                            [@explicit_arity ]))) b)) (inp ## inner)));
             (\\"enum\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                ((match a with
                                  | \`FIRST -> Js.Json.string \\"FIRST\\"
                                  | \`SECOND -> Js.Json.string \\"SECOND\\"
                                  | \`THIRD -> Js.Json.string \\"THIRD\\")))
                            [@explicit_arity ]))) b)) (inp ## enum)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectRecursiveInput ?otherField  ?inner  ?enum  () =
      ([%bs.obj { otherField; inner; enum }] : t_variables_RecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects scalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < variousScalars: t_variousScalars   >  Js.t
    and t_variousScalars =
      <
        nullableString: string option  ;string: string  ;nullableInt: 
                                                           int option  ;
        int: int  ;nullableFloat: float option  ;float: float  ;nullableBoolean: 
                                                                  bool option
                                                                   ;boolean: 
                                                                    bool  ;
        nullableID: string option  ;id: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             variousScalars =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableString =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None);
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       (Obj.magic value : string));
                    nullableInt =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableInt\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : int)))
                           [@explicit_arity ])
                       | None -> None);
                    int =
                      (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                       (Obj.magic value : int));
                    nullableFloat =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableFloat\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : float)))
                           [@explicit_arity ])
                       | None -> None);
                    float =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"float\\" in
                       (Obj.magic value : float));
                    nullableBoolean =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nullableBoolean\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : bool)))
                           [@explicit_arity ])
                       | None -> None);
                    boolean =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"boolean\\" in
                       (Obj.magic value : bool));
                    nullableID =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableID\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None);
                    id =
                      (let value = Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                       (Obj.magic value : string))
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects scalarsArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\"
    type raw_t
    type t = < scalarsInput: string   >  Js.t
    type t_variables =
      <
        nullableString: string option  ;string: string  ;nullableInt: 
                                                           int option  ;
        int: int  ;nullableFloat: float option  ;float: float  ;nullableBoolean: 
                                                                  bool option
                                                                   ;boolean: 
                                                                    bool  ;
        nullableID: string option  ;id: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             scalarsInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"scalarsInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableString\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## nullableString)));
             (\\"string\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## string)));(\\"nullableInt\\",
                                      (((fun a ->
                                           match a with
                                           | None -> None
                                           | ((Some (b))[@explicit_arity ])
                                               ->
                                               ((fun a ->
                                                   ((Some
                                                       ((Js.Json.number
                                                           (float_of_int a))))
                                                   [@explicit_arity ]))) b))
                                         (inp ## nullableInt)));(\\"int\\",
                                                                  (((fun a ->
                                                                    ((Some
                                                                    ((Js.Json.number
                                                                    (float_of_int
                                                                    a))))
                                                                    [@explicit_arity
                                                                    ])))
                                                                    (inp ##
                                                                    int)));
             (\\"nullableFloat\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.number a)))
                            [@explicit_arity ]))) b)) (inp ## nullableFloat)));
             (\\"float\\",
               (((fun a -> ((Some ((Js.Json.number a)))[@explicit_arity ])))
                  (inp ## float)));(\\"nullableBoolean\\",
                                     (((fun a ->
                                          match a with
                                          | None -> None
                                          | ((Some (b))[@explicit_arity ]) ->
                                              ((fun a ->
                                                  ((Some
                                                      ((Js.Json.boolean a)))
                                                  [@explicit_arity ]))) b))
                                        (inp ## nullableBoolean)));(\\"boolean\\",
                                                                    (((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.boolean
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ])))
                                                                    (inp ##
                                                                    boolean)));
             (\\"nullableID\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## nullableID)));
             (\\"id\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## id)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?nullableString  ~string  ?nullableInt  ~int 
      ?nullableFloat  ~float  ?nullableBoolean  ~boolean  ?nullableID  ~id 
      () =
      f
        (serializeVariables
           ([%bs.obj
              {
                nullableString;
                string;
                nullableInt;
                int;
                nullableFloat;
                float;
                nullableBoolean;
                boolean;
                nullableID;
                id
              }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects scalarsInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < scalarsInput: string   >  Js.t
    type t_variables = < arg: t_variables_VariousScalarsInput   >  Js.t
    and t_variables_VariousScalarsInput =
      <
        nullableString: string option  ;string: string  ;nullableInt: 
                                                           int option  ;
        int: int  ;nullableFloat: float option  ;float: float  ;nullableBoolean: 
                                                                  bool option
                                                                   ;boolean: 
                                                                    bool  ;
        nullableID: string option  ;id: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             scalarsInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"scalarsInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectVariousScalarsInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectVariousScalarsInput :
      t_variables_VariousScalarsInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableString\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## nullableString)));
             (\\"string\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## string)));(\\"nullableInt\\",
                                      (((fun a ->
                                           match a with
                                           | None -> None
                                           | ((Some (b))[@explicit_arity ])
                                               ->
                                               ((fun a ->
                                                   ((Some
                                                       ((Js.Json.number
                                                           (float_of_int a))))
                                                   [@explicit_arity ]))) b))
                                         (inp ## nullableInt)));(\\"int\\",
                                                                  (((fun a ->
                                                                    ((Some
                                                                    ((Js.Json.number
                                                                    (float_of_int
                                                                    a))))
                                                                    [@explicit_arity
                                                                    ])))
                                                                    (inp ##
                                                                    int)));
             (\\"nullableFloat\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.number a)))
                            [@explicit_arity ]))) b)) (inp ## nullableFloat)));
             (\\"float\\",
               (((fun a -> ((Some ((Js.Json.number a)))[@explicit_arity ])))
                  (inp ## float)));(\\"nullableBoolean\\",
                                     (((fun a ->
                                          match a with
                                          | None -> None
                                          | ((Some (b))[@explicit_arity ]) ->
                                              ((fun a ->
                                                  ((Some
                                                      ((Js.Json.boolean a)))
                                                  [@explicit_arity ]))) b))
                                        (inp ## nullableBoolean)));(\\"boolean\\",
                                                                    (((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.boolean
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ])))
                                                                    (inp ##
                                                                    boolean)));
             (\\"nullableID\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## nullableID)));
             (\\"id\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## id)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectVariousScalarsInput ?nullableString  ~string 
      ?nullableInt  ~int  ?nullableFloat  ~float  ?nullableBoolean  ~boolean 
      ?nullableID  ~id  () =
      ([%bs.obj
         {
           nullableString;
           string;
           nullableInt;
           int;
           nullableFloat;
           float;
           nullableBoolean;
           boolean;
           nullableID;
           id
         }] : t_variables_VariousScalarsInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects skipDirectives.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < v1: t_v1  ;v2: t_v2   >  Js.t
    and t_v2 =
      < nullableString: string option  ;string: string option   >  Js.t
    and t_v1 =
      < nullableString: string option  ;string: string option   >  Js.t
    type t_variables = < var: bool   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             v1 =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"v1\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableString =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None);
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None)
                  }]);
             v2 =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"v2\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableString =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None);
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"var\\",
               (((fun a -> ((Some ((Js.Json.boolean a)))[@explicit_arity ])))
                  (inp ## var)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~var  () =
      f (serializeVariables ([%bs.obj { var }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Objects subscription.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      <
        simpleSubscription: [ \`Dog of t_simpleSubscription_Dog 
                            | \`Human of t_simpleSubscription_Human ]   > 
        Js.t
    and t_simpleSubscription_Human = < name: string   >  Js.t
    and t_simpleSubscription_Dog = < name: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             simpleSubscription =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"simpleSubscription\\" in
                match Js.Json.decodeObject value with
                | None ->
                    Js.Exn.raiseError
                      (\\"graphql_ppx: \\" ^
                         (\\"Expected union \\" ^
                            (\\"DogOrHuman\\" ^
                               (\\" to be an object, got \\" ^
                                  (Js.Json.stringify value)))))
                | ((Some (typename_obj))[@explicit_arity ]) ->
                    (match Js.Dict.get typename_obj \\"__typename\\" with
                     | None ->
                         Js.Exn.raiseError
                           (\\"graphql_ppx: \\" ^
                              (\\"Union \\" ^
                                 (\\"DogOrHuman\\" ^
                                    \\" is missing the __typename field\\")))
                     | ((Some (typename))[@explicit_arity ]) ->
                         (match Js.Json.decodeString typename with
                          | None ->
                              Js.Exn.raiseError
                                (\\"graphql_ppx: \\" ^
                                   (\\"Union \\" ^
                                      (\\"DogOrHuman\\" ^
                                         \\" has a __typename field that is not a string\\")))
                          | ((Some (typename))[@explicit_arity ]) ->
                              ((match typename with
                                | \\"Dog\\" ->
                                    \`Dog
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string))
                                         }])
                                | \\"Human\\" ->
                                    \`Human
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string))
                                         }])
                                | typename ->
                                    Js.Exn.raiseError
                                      (\\"graphql_ppx: \\" ^
                                         (\\"Union \\" ^
                                            (\\"DogOrHuman\\" ^
                                               (\\" returned unknown type \\" ^
                                                  typename))))) : [
                                                                    \`Dog of _ 
                                                                  | \`Human of
                                                                    _ ]))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects typename.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < first: t_first   >  Js.t
    and t_first =
      < __typename: string  ;inner: t_first_inner option   >  Js.t
    and t_first_inner =
      < __typename: string  ;inner: t_first_inner_inner option   >  Js.t
    and t_first_inner_inner = < __typename: string  ;field: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             first =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"first\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    __typename =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"__typename\\" in
                       (Obj.magic value : string));
                    inner =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               ((let value =
                                   (value |> Js.Json.decodeObject) |>
                                     Js.Option.getExn[@@metaloc loc] in
                                 [%bs.obj
                                   {
                                     __typename =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"__typename\\" in
                                        (Obj.magic value : string));
                                     inner =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"inner\\" in
                                        (match Js.toOption
                                                 (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                         with
                                         | Some _ ->
                                             ((Some
                                                 ((let value =
                                                     (value |>
                                                        Js.Json.decodeObject)
                                                       |> Js.Option.getExn
                                                     [@@metaloc loc] in
                                                   [%bs.obj
                                                     {
                                                       __typename =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value)
                                                              \\"__typename\\" in
                                                          (Obj.magic value : 
                                                            string));
                                                       field =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value)
                                                              \\"field\\" in
                                                          (Obj.magic value : 
                                                            string))
                                                     }])))
                                             [@explicit_arity ])
                                         | None -> None))
                                   }])))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects union.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      <
        dogOrHuman: [ \`Dog of t_dogOrHuman_Dog 
                    | \`Human of t_dogOrHuman_Human ]   > 
        Js.t
    and t_dogOrHuman_Human = < name: string   >  Js.t
    and t_dogOrHuman_Dog = < name: string  ;barkVolume: float   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             dogOrHuman =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                match Js.Json.decodeObject value with
                | None ->
                    Js.Exn.raiseError
                      (\\"graphql_ppx: \\" ^
                         (\\"Expected union \\" ^
                            (\\"DogOrHuman\\" ^
                               (\\" to be an object, got \\" ^
                                  (Js.Json.stringify value)))))
                | ((Some (typename_obj))[@explicit_arity ]) ->
                    (match Js.Dict.get typename_obj \\"__typename\\" with
                     | None ->
                         Js.Exn.raiseError
                           (\\"graphql_ppx: \\" ^
                              (\\"Union \\" ^
                                 (\\"DogOrHuman\\" ^
                                    \\" is missing the __typename field\\")))
                     | ((Some (typename))[@explicit_arity ]) ->
                         (match Js.Json.decodeString typename with
                          | None ->
                              Js.Exn.raiseError
                                (\\"graphql_ppx: \\" ^
                                   (\\"Union \\" ^
                                      (\\"DogOrHuman\\" ^
                                         \\" has a __typename field that is not a string\\")))
                          | ((Some (typename))[@explicit_arity ]) ->
                              ((match typename with
                                | \\"Dog\\" ->
                                    \`Dog
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string));
                                           barkVolume =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value)
                                                  \\"barkVolume\\" in
                                              (Obj.magic value : float))
                                         }])
                                | \\"Human\\" ->
                                    \`Human
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string))
                                         }])
                                | typename ->
                                    Js.Exn.raiseError
                                      (\\"graphql_ppx: \\" ^
                                         (\\"Union \\" ^
                                            (\\"DogOrHuman\\" ^
                                               (\\" returned unknown type \\" ^
                                                  typename))))) : [
                                                                    \`Dog of _ 
                                                                  | \`Human of
                                                                    _ ]))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Objects unionPartial.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      < dogOrHuman: [ \`Nonexhaustive  | \`Dog of t_dogOrHuman_Dog ]   >  Js.t
    and t_dogOrHuman_Dog = < name: string  ;barkVolume: float   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             dogOrHuman =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                match Js.Json.decodeObject value with
                | None ->
                    Js.Exn.raiseError
                      (\\"graphql_ppx: \\" ^
                         (\\"Expected union \\" ^
                            (\\"DogOrHuman\\" ^
                               (\\" to be an object, got \\" ^
                                  (Js.Json.stringify value)))))
                | ((Some (typename_obj))[@explicit_arity ]) ->
                    (match Js.Dict.get typename_obj \\"__typename\\" with
                     | None ->
                         Js.Exn.raiseError
                           (\\"graphql_ppx: \\" ^
                              (\\"Union \\" ^
                                 (\\"DogOrHuman\\" ^
                                    \\" is missing the __typename field\\")))
                     | ((Some (typename))[@explicit_arity ]) ->
                         (match Js.Json.decodeString typename with
                          | None ->
                              Js.Exn.raiseError
                                (\\"graphql_ppx: \\" ^
                                   (\\"Union \\" ^
                                      (\\"DogOrHuman\\" ^
                                         \\" has a __typename field that is not a string\\")))
                          | ((Some (typename))[@explicit_arity ]) ->
                              ((match typename with
                                | \\"Dog\\" ->
                                    \`Dog
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string));
                                           barkVolume =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value)
                                                  \\"barkVolume\\" in
                                              (Obj.magic value : float))
                                         }])
                                | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                         | \`Dog of _ ]))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy argNamedQuery.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\"
    type raw_t
    type t = < argNamedQuery: int   >  Js.t
    type t_variables = < query: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             argNamedQuery =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"argNamedQuery\\" in
                (Obj.magic value : int))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"query\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## query)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~query  () =
      f (serializeVariables ([%bs.obj { query }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy comment.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < nonrecursiveInput: string   >  Js.t
    type t_variables = < arg: t_variables_NonrecursiveInput   >  Js.t
    and t_variables_NonrecursiveInput =
      < field: string option  ;enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option  
        >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             nonrecursiveInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"nonrecursiveInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectNonrecursiveInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectNonrecursiveInput :
      t_variables_NonrecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"field\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## field)));
             (\\"enum\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                ((match a with
                                  | \`FIRST -> Js.Json.string \\"FIRST\\"
                                  | \`SECOND -> Js.Json.string \\"SECOND\\"
                                  | \`THIRD -> Js.Json.string \\"THIRD\\")))
                            [@explicit_arity ]))) b)) (inp ## enum)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectNonrecursiveInput ?field  ?enum  () =
      ([%bs.obj { field; enum }] : t_variables_NonrecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy customDecoder.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module StringOfInt = struct let parse = string_of_int
                            type t = string end
module IntOfString = struct let parse = int_of_string
                            type t = int end
module MyQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < variousScalars: t_variousScalars   >  Js.t
    and t_variousScalars =
      < string: IntOfString.t  ;int: StringOfInt.t   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             variousScalars =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       IntOfString.parse (Obj.magic value : string));
                    int =
                      (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                       StringOfInt.parse (Obj.magic value : int))
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy customScalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < customScalarField: t_customScalarField   >  Js.t
    and t_customScalarField =
      < nullable: Js.Json.t option  ;nonNullable: Js.Json.t   >  Js.t
    type t_variables = < opt: Js.Json.t option  ;req: Js.Json.t   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             customScalarField =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"customScalarField\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullable\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some (value))[@explicit_arity ])
                       | None -> None);
                    nonNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nonNullable\\" in
                       value)
                  }])
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"opt\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some (a))[@explicit_arity ]))) b))
                  (inp ## opt)));(\\"req\\",
                                   (((fun a -> ((Some (a))[@explicit_arity ])))
                                      (inp ## req)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?opt  ~req  () =
      f (serializeVariables ([%bs.obj { opt; req }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy enumInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < enumInput: string   >  Js.t
    type t_variables = < arg: [ \`FIRST  | \`SECOND  | \`THIRD ]   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             enumInput =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"enumInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some
                        ((match a with
                          | \`FIRST -> Js.Json.string \\"FIRST\\"
                          | \`SECOND -> Js.Json.string \\"SECOND\\"
                          | \`THIRD -> Js.Json.string \\"THIRD\\")))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy fragmentDefinition.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module Fragments =
  struct
    let query =
      \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\"
    type t =
      <
        nullableOfNullable: string option array option  ;nullableOfNonNullable: 
                                                           string array
                                                             option   > 
        Js.t
    type raw_t
    type t_Lists = t
    let parse (value : Js.Json.t) =
      let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
        [@@metaloc loc] in
      [%bs.obj
        {
          nullableOfNullable =
            (let value =
               Js.Dict.unsafeGet (Obj.magic value) \\"nullableOfNullable\\" in
             match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
             | Some _ ->
                 ((Some
                     (((Obj.magic value) |>
                         (Js.Array.map
                            (fun value ->
                               match Js.toOption
                                       (Obj.magic value : 'a Js.Nullable.t)
                               with
                               | Some _ ->
                                   ((Some ((Obj.magic value : string)))
                                   [@explicit_arity ])
                               | None -> None)))))
                 [@explicit_arity ])
             | None -> None);
          nullableOfNonNullable =
            (let value =
               Js.Dict.unsafeGet (Obj.magic value) \\"nullableOfNonNullable\\" in
             match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
             | Some _ ->
                 ((Some
                     (((Obj.magic value) |>
                         (Js.Array.map
                            (fun value -> (Obj.magic value : string))))))
                 [@explicit_arity ])
             | None -> None)
        }]
    let name = \\"ListFragment\\"
  end
module MyQuery =
  struct
    let query =
      ((((((\\"query   {\\\\nl1: lists  {\\\\n...\\" ^ Fragments.ListFragment.name) ^
             \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\")
            ^ Fragments.ListFragment.name)
           ^ \\"   \\\\n...\\")
          ^ Fragments.ListFragment.name)
         ^ \\"   \\\\n}\\\\n\\\\n}\\\\n\\")
        ^ Fragments.ListFragment.query
    type raw_t
    type t = < l1: Fragments.ListFragment.t  ;l2: t_l2   >  Js.t
    and t_l2 =
      <
        frag1: Fragments.ListFragment.t_Lists  ;frag2: Fragments.ListFragment.t_Lists
                                                    > 
        Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             l1 =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"l1\\" in
                Fragments.ListFragment.parse value);
             l2 =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"l2\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    frag1 = (Fragments.ListFragment.parse value);
                    frag2 = (Fragments.ListFragment.parse value)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy interface.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module QueryWithFragments =
  struct
    let query =
      \\"query   {\\\\nusers  {\\\\n__typename\\\\nid  \\\\n...on AdminUser   {\\\\nname  \\\\n}\\\\n\\\\n...on AnonymousUser   {\\\\nanonymousId  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      <
        users: [ \`User of t_users_User 
               | \`AnonymousUser of t_users_AnonymousUser 
               | \`AdminUser of t_users_AdminUser ] array   > 
        Js.t
    and t_users_AdminUser = < id: string  ;name: string   >  Js.t
    and t_users_AnonymousUser = < id: string  ;anonymousId: int   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             users =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"users\\" in
                (Obj.magic value) |>
                  (Js.Array.map
                     (fun value ->
                        match Js.Json.decodeObject value with
                        | None ->
                            Js.Exn.raiseError
                              (\\"graphql_ppx: \\" ^
                                 (\\"Expected Interface implementation \\" ^
                                    (\\"User\\" ^
                                       (\\" to be an object, got \\" ^
                                          (Js.Json.stringify value)))))
                        | ((Some (typename_obj))[@explicit_arity ]) ->
                            (match Js.Dict.get typename_obj \\"__typename\\" with
                             | None ->
                                 Js.Exn.raiseError
                                   (\\"graphql_ppx: \\" ^
                                      (\\"Interface implementation\\" ^
                                         (\\"User\\" ^
                                            \\" is missing the __typename field\\")))
                             | ((Some (typename))[@explicit_arity ]) ->
                                 (match Js.Json.decodeString typename with
                                  | None ->
                                      Js.Exn.raiseError
                                        (\\"graphql_ppx: \\" ^
                                           (\\"Interface implementation \\" ^
                                              (\\"User\\" ^
                                                 \\" has a __typename field that is not a string\\")))
                                  | ((Some (typename))[@explicit_arity ]) ->
                                      ((match typename with
                                        | \\"AnonymousUser\\" ->
                                            \`AnonymousUser
                                              (let value =
                                                 (value |>
                                                    Js.Json.decodeObject)
                                                   |> Js.Option.getExn
                                                 [@@metaloc loc] in
                                               [%bs.obj
                                                 {
                                                   id =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"id\\" in
                                                      (Obj.magic value : 
                                                        string));
                                                   anonymousId =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"anonymousId\\" in
                                                      (Obj.magic value : 
                                                        int))
                                                 }])
                                        | \\"AdminUser\\" ->
                                            \`AdminUser
                                              (let value =
                                                 (value |>
                                                    Js.Json.decodeObject)
                                                   |> Js.Option.getExn
                                                 [@@metaloc loc] in
                                               [%bs.obj
                                                 {
                                                   id =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"id\\" in
                                                      (Obj.magic value : 
                                                        string));
                                                   name =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"name\\" in
                                                      (Obj.magic value : 
                                                        string))
                                                 }])
                                        | _ ->
                                            \`User
                                              (let value =
                                                 (value |>
                                                    Js.Json.decodeObject)
                                                   |> Js.Option.getExn
                                                 [@@metaloc loc] in
                                               [%bs.obj
                                                 {
                                                   id =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"id\\" in
                                                      (Obj.magic value : 
                                                        string))
                                                 }])) : [ \`User of _ 
                                                        | \`AnonymousUser of _ 
                                                        | \`AdminUser of _ ]))))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module QueryWithoutFragments =
  struct
    let query = \\"query   {\\\\nusers  {\\\\n__typename\\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < users: [ \`User of t_users_User ] array   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             users =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"users\\" in
                (Obj.magic value) |>
                  (Js.Array.map
                     (fun value ->
                        match Js.Json.decodeObject value with
                        | None ->
                            Js.Exn.raiseError
                              (\\"graphql_ppx: \\" ^
                                 (\\"Expected Interface implementation \\" ^
                                    (\\"User\\" ^
                                       (\\" to be an object, got \\" ^
                                          (Js.Json.stringify value)))))
                        | ((Some (typename_obj))[@explicit_arity ]) ->
                            (match Js.Dict.get typename_obj \\"__typename\\" with
                             | None ->
                                 Js.Exn.raiseError
                                   (\\"graphql_ppx: \\" ^
                                      (\\"Interface implementation\\" ^
                                         (\\"User\\" ^
                                            \\" is missing the __typename field\\")))
                             | ((Some (typename))[@explicit_arity ]) ->
                                 (match Js.Json.decodeString typename with
                                  | None ->
                                      Js.Exn.raiseError
                                        (\\"graphql_ppx: \\" ^
                                           (\\"Interface implementation \\" ^
                                              (\\"User\\" ^
                                                 \\" has a __typename field that is not a string\\")))
                                  | ((Some (typename))[@explicit_arity ]) ->
                                      ((match typename with
                                        | _ ->
                                            \`User
                                              (let value =
                                                 (value |>
                                                    Js.Json.decodeObject)
                                                   |> Js.Option.getExn
                                                 [@@metaloc loc] in
                                               [%bs.obj
                                                 {
                                                   id =
                                                     (let value =
                                                        Js.Dict.unsafeGet
                                                          (Obj.magic value)
                                                          \\"id\\" in
                                                      (Obj.magic value : 
                                                        string))
                                                 }])) : [ \`User of _ ]))))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy lists.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < lists: t_lists   >  Js.t
    and t_lists =
      <
        nullableOfNullable: string option array option  ;nullableOfNonNullable: 
                                                           string array
                                                             option  ;
        nonNullableOfNullable: string option array  ;nonNullableOfNonNullable: 
                                                       string array   > 
        Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             lists =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"lists\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableOfNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nullableOfNullable\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               (((Obj.magic value) |>
                                   (Js.Array.map
                                      (fun value ->
                                         match Js.toOption
                                                 (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                         with
                                         | Some _ ->
                                             ((Some
                                                 ((Obj.magic value : string)))
                                             [@explicit_arity ])
                                         | None -> None)))))
                           [@explicit_arity ])
                       | None -> None);
                    nullableOfNonNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nullableOfNonNullable\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               (((Obj.magic value) |>
                                   (Js.Array.map
                                      (fun value ->
                                         (Obj.magic value : string))))))
                           [@explicit_arity ])
                       | None -> None);
                    nonNullableOfNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nonNullableOfNullable\\" in
                       (Obj.magic value) |>
                         (Js.Array.map
                            (fun value ->
                               match Js.toOption
                                       (Obj.magic value : 'a Js.Nullable.t)
                               with
                               | Some _ ->
                                   ((Some ((Obj.magic value : string)))
                                   [@explicit_arity ])
                               | None -> None)));
                    nonNullableOfNonNullable =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nonNullableOfNonNullable\\" in
                       (Obj.magic value) |>
                         (Js.Array.map
                            (fun value -> (Obj.magic value : string))))
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy listsArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\"
    type raw_t
    type t = < listsInput: string   >  Js.t
    type t_variables =
      <
        nullableOfNullable: string option array option  ;nullableOfNonNullable: 
                                                           string array
                                                             option  ;
        nonNullableOfNullable: string option array  ;nonNullableOfNonNullable: 
                                                       string array   > 
        Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             listsInput =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"listsInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableOfNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    match a with
                                                    | None -> None
                                                    | ((Some
                                                        (b))[@explicit_arity
                                                              ])
                                                        ->
                                                        ((fun a ->
                                                            ((Some
                                                                ((Js.Json.string
                                                                    a)))
                                                            [@explicit_arity
                                                              ]))) b) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b))
                  (inp ## nullableOfNullable)));(\\"nullableOfNonNullable\\",
                                                  (((fun a ->
                                                       match a with
                                                       | None -> None
                                                       | ((Some
                                                           (b))[@explicit_arity
                                                                 ])
                                                           ->
                                                           ((fun a ->
                                                               ((Some
                                                                   (((a |>
                                                                    (Array.map
                                                                    (fun b ->
                                                                    match 
                                                                    (fun a ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ])) b
                                                                    with
                                                                    | 
                                                                    ((Some
                                                                    (c))
                                                                    [@explicit_arity
                                                                    ]) -> c
                                                                    | 
                                                                    None ->
                                                                    Js.Json.null)))
                                                                    |>
                                                                    Js.Json.array)))
                                                               [@explicit_arity
                                                                 ]))) b))
                                                     (inp ##
                                                        nullableOfNonNullable)));
             (\\"nonNullableOfNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            match a with
                                            | None -> None
                                            | ((Some (b))[@explicit_arity ])
                                                ->
                                                ((fun a ->
                                                    ((Some
                                                        ((Js.Json.string a)))
                                                    [@explicit_arity ]))) b)
                                           b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) (inp ## nonNullableOfNullable)));
             (\\"nonNullableOfNonNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            ((Some ((Js.Json.string a)))
                                            [@explicit_arity ])) b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) (inp ## nonNullableOfNonNullable)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?nullableOfNullable  ?nullableOfNonNullable 
      ~nonNullableOfNullable  ~nonNullableOfNonNullable  () =
      f
        (serializeVariables
           ([%bs.obj
              {
                nullableOfNullable;
                nullableOfNonNullable;
                nonNullableOfNullable;
                nonNullableOfNonNullable
              }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy listsInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < listsInput: string   >  Js.t
    type t_variables = < arg: t_variables_ListsInput   >  Js.t
    and t_variables_ListsInput =
      <
        nullableOfNullable: string option array option  ;nullableOfNonNullable: 
                                                           string array
                                                             option  ;
        nonNullableOfNullable: string option array  ;nonNullableOfNonNullable: 
                                                       string array   > 
        Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             listsInput =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"listsInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a -> ((Some ((serializeInputObjectListsInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectListsInput :
      t_variables_ListsInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableOfNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    match a with
                                                    | None -> None
                                                    | ((Some
                                                        (b))[@explicit_arity
                                                              ])
                                                        ->
                                                        ((fun a ->
                                                            ((Some
                                                                ((Js.Json.string
                                                                    a)))
                                                            [@explicit_arity
                                                              ]))) b) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b))
                  (inp ## nullableOfNullable)));(\\"nullableOfNonNullable\\",
                                                  (((fun a ->
                                                       match a with
                                                       | None -> None
                                                       | ((Some
                                                           (b))[@explicit_arity
                                                                 ])
                                                           ->
                                                           ((fun a ->
                                                               ((Some
                                                                   (((a |>
                                                                    (Array.map
                                                                    (fun b ->
                                                                    match 
                                                                    (fun a ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ])) b
                                                                    with
                                                                    | 
                                                                    ((Some
                                                                    (c))
                                                                    [@explicit_arity
                                                                    ]) -> c
                                                                    | 
                                                                    None ->
                                                                    Js.Json.null)))
                                                                    |>
                                                                    Js.Json.array)))
                                                               [@explicit_arity
                                                                 ]))) b))
                                                     (inp ##
                                                        nullableOfNonNullable)));
             (\\"nonNullableOfNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            match a with
                                            | None -> None
                                            | ((Some (b))[@explicit_arity ])
                                                ->
                                                ((fun a ->
                                                    ((Some
                                                        ((Js.Json.string a)))
                                                    [@explicit_arity ]))) b)
                                           b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) (inp ## nonNullableOfNullable)));
             (\\"nonNullableOfNonNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            ((Some ((Js.Json.string a)))
                                            [@explicit_arity ])) b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) (inp ## nonNullableOfNonNullable)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectListsInput ?nullableOfNullable  ?nullableOfNonNullable
       ~nonNullableOfNullable  ~nonNullableOfNonNullable  () =
      ([%bs.obj
         {
           nullableOfNullable;
           nullableOfNonNullable;
           nonNullableOfNullable;
           nonNullableOfNonNullable
         }] : t_variables_ListsInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy mutation.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < mutationWithError: t_mutationWithError   >  Js.t
    and t_mutationWithError =
      <
        value: t_mutationWithError_value option  ;errors: t_mutationWithError_errors
                                                            array option   > 
        Js.t
    and t_mutationWithError_errors =
      < field: [ \`FIRST  | \`SECOND  | \`THIRD ]  ;message: string   >  Js.t
    and t_mutationWithError_value = < stringField: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             mutationWithError =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"mutationWithError\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    value =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"value\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               ((let value =
                                   (value |> Js.Json.decodeObject) |>
                                     Js.Option.getExn[@@metaloc loc] in
                                 [%bs.obj
                                   {
                                     stringField =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"stringField\\" in
                                        (Obj.magic value : string))
                                   }])))
                           [@explicit_arity ])
                       | None -> None);
                    errors =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"errors\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               (((Obj.magic value) |>
                                   (Js.Array.map
                                      (fun value ->
                                         let value =
                                           (value |> Js.Json.decodeObject) |>
                                             Js.Option.getExn[@@metaloc loc] in
                                         [%bs.obj
                                           {
                                             field =
                                               (let value =
                                                  Js.Dict.unsafeGet
                                                    (Obj.magic value) \\"field\\" in
                                                match Js.Json.decodeString
                                                        value
                                                with
                                                | None ->
                                                    Js.Exn.raiseError
                                                      (\\"graphql_ppx: \\" ^
                                                         (\\"Expected enum value for \\"
                                                            ^
                                                            (\\"SampleField\\" ^
                                                               (\\", got \\" ^
                                                                  (Js.Json.stringify
                                                                    value)))))
                                                | ((Some
                                                    (value))[@explicit_arity
                                                              ])
                                                    ->
                                                    ((match value with
                                                      | \\"FIRST\\" -> \`FIRST
                                                      | \\"SECOND\\" -> \`SECOND
                                                      | \\"THIRD\\" -> \`THIRD
                                                      | _ ->
                                                          Js.Exn.raiseError
                                                            (\\"graphql_ppx: \\"
                                                               ^
                                                               (\\"Unknown enum variant for \\"
                                                                  ^
                                                                  (\\"SampleField\\"
                                                                    ^
                                                                    (\\": \\" ^
                                                                    value))))) : 
                                                    [ \`FIRST  | \`SECOND 
                                                    | \`THIRD ]));
                                             message =
                                               (let value =
                                                  Js.Dict.unsafeGet
                                                    (Obj.magic value)
                                                    \\"message\\" in
                                                (Obj.magic value : string))
                                           }])))))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy mutationWithArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\"
    type raw_t
    type t = < optionalInputArgs: string   >  Js.t
    type t_variables = < required: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             optionalInputArgs =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"optionalInputArgs\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"required\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## required)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~required  () =
      f (serializeVariables ([%bs.obj { required }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy nested.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
type record = {
  f1: string ;
  f2: string }
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < first: t_first  ;second: t_second   >  Js.t
    and t_second = < inner: t_second_inner option   >  Js.t
    and t_second_inner = < inner: t_second_inner_inner option   >  Js.t
    and t_second_inner_inner = {
      f1: string ;
      f2: string }
    and t_first = < inner: t_first_inner option   >  Js.t
    and t_first_inner = < inner: t_first_inner_inner option   >  Js.t
    and t_first_inner_inner = < field: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             first =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"first\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    inner =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               ((let value =
                                   (value |> Js.Json.decodeObject) |>
                                     Js.Option.getExn[@@metaloc loc] in
                                 [%bs.obj
                                   {
                                     inner =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"inner\\" in
                                        (match Js.toOption
                                                 (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                         with
                                         | Some _ ->
                                             ((Some
                                                 ((let value =
                                                     (value |>
                                                        Js.Json.decodeObject)
                                                       |> Js.Option.getExn
                                                     [@@metaloc loc] in
                                                   [%bs.obj
                                                     {
                                                       field =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value)
                                                              \\"field\\" in
                                                          (Obj.magic value : 
                                                            string))
                                                     }])))
                                             [@explicit_arity ])
                                         | None -> None))
                                   }])))
                           [@explicit_arity ])
                       | None -> None)
                  }]);
             second =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"second\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    inner =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               ((let value =
                                   (value |> Js.Json.decodeObject) |>
                                     Js.Option.getExn[@@metaloc loc] in
                                 [%bs.obj
                                   {
                                     inner =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"inner\\" in
                                        (match Js.toOption
                                                 (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                         with
                                         | Some _ ->
                                             ((Some
                                                 ((let value =
                                                     (value |>
                                                        Js.Json.decodeObject)
                                                       |> Js.Option.getExn
                                                     [@@metaloc loc] in
                                                   [%bs.obj
                                                     {
                                                       f1 =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value) \\"f1\\" in
                                                          (Obj.magic value : 
                                                            string));
                                                       f2 =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value) \\"f2\\" in
                                                          (Obj.magic value : 
                                                            string))
                                                     }])))
                                             [@explicit_arity ])
                                         | None -> None))
                                   }])))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy nonrecursiveInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < nonrecursiveInput: string   >  Js.t
    type t_variables = < arg: t_variables_NonrecursiveInput   >  Js.t
    and t_variables_NonrecursiveInput =
      < field: string option  ;enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option  
        >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             nonrecursiveInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"nonrecursiveInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectNonrecursiveInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectNonrecursiveInput :
      t_variables_NonrecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"field\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## field)));
             (\\"enum\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                ((match a with
                                  | \`FIRST -> Js.Json.string \\"FIRST\\"
                                  | \`SECOND -> Js.Json.string \\"SECOND\\"
                                  | \`THIRD -> Js.Json.string \\"THIRD\\")))
                            [@explicit_arity ]))) b)) (inp ## enum)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectNonrecursiveInput ?field  ?enum  () =
      ([%bs.obj { field; enum }] : t_variables_NonrecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy pokedexApolloMode.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < pokemon: t_pokemon option   >  Js.t
    and t_pokemon = < id: string  ;name: string option   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             pokemon =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"pokemon\\" in
                match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
                | Some _ ->
                    ((Some
                        ((let value =
                            (value |> Js.Json.decodeObject) |>
                              Js.Option.getExn[@@metaloc loc] in
                          [%bs.obj
                            {
                              id =
                                (let value =
                                   Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                                 (Obj.magic value : string));
                              name =
                                (let value =
                                   Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                                 (match Js.toOption
                                          (Obj.magic value : 'a Js.Nullable.t)
                                  with
                                  | Some _ ->
                                      ((Some ((Obj.magic value : string)))
                                      [@explicit_arity ])
                                  | None -> None))
                            }])))
                    [@explicit_arity ])
                | None -> None)
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy pokedexScalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < pokemon: t_pokemon option   >  Js.t
    and t_pokemon = < id: string  ;name: string option   >  Js.t
    type t_variables = < id: string option  ;name: string option   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             pokemon =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"pokemon\\" in
                match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
                | Some _ ->
                    ((Some
                        ((let value =
                            (value |> Js.Json.decodeObject) |>
                              Js.Option.getExn[@@metaloc loc] in
                          [%bs.obj
                            {
                              id =
                                (let value =
                                   Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                                 (Obj.magic value : string));
                              name =
                                (let value =
                                   Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                                 (match Js.toOption
                                          (Obj.magic value : 'a Js.Nullable.t)
                                  with
                                  | Some _ ->
                                      ((Some ((Obj.magic value : string)))
                                      [@explicit_arity ])
                                  | None -> None))
                            }])))
                    [@explicit_arity ])
                | None -> None)
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"id\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## id)));(\\"name\\",
                                                                    (((fun a
                                                                    ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    (inp ##
                                                                    name)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?id  ?name  () =
      f (serializeVariables ([%bs.obj { id; name }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy record.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
type scalars = {
  string: string ;
  int: int }
type dog = {
  name: string ;
  barkVolume: float }
type oneFieldQuery = {
  nullableString: string option }
module MyQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < variousScalars: t_variousScalars   >  Js.t
    and t_variousScalars = {
      string: string ;
      int: int }
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             variousScalars =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       (Obj.magic value : string));
                    int =
                      (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                       (Obj.magic value : int))
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module OneFieldQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < variousScalars: t_variousScalars   >  Js.t
    and t_variousScalars = {
      nullableString: string option }
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             variousScalars =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableString =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module ExternalFragmentQuery =
  struct
    module Fragment =
      struct
        let query =
          \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\"
        type t = {
          string: string ;
          int: int }
        type raw_t
        type t_VariousScalars = t
        let parse (value : Js.Json.t) =
          let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
            [@@metaloc loc] in
          [%bs.obj
            {
              string =
                (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                 (Obj.magic value : string));
              int =
                (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                 (Obj.magic value : int))
            }]
        let name = \\"Fragment\\"
      end
    module Untitled1 =
      struct
        let query =
          ((\\"query   {\\\\nvariousScalars  {\\\\n...\\" ^ Fragment.name) ^
             \\"   \\\\n}\\\\n\\\\n}\\\\n\\")
            ^ Fragment.query
        type raw_t
        type t = < variousScalars: Fragment.t   >  Js.t
        let parse =
          (fun value ->
             let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
               [@@metaloc loc] in
             [%bs.obj
               {
                 variousScalars =
                   (let value =
                      Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                    Fragment.parse value)
               }] : Js.Json.t -> t)
        let makeVar ~f  () = f Js.Json.null
        let definition = (parse, query, makeVar)
      end
  end
module InlineFragmentQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      < dogOrHuman: [ \`Nonexhaustive  | \`Dog of t_dogOrHuman_Dog ]   >  Js.t
    and t_dogOrHuman_Dog = {
      name: string ;
      barkVolume: float }
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             dogOrHuman =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                match Js.Json.decodeObject value with
                | None ->
                    Js.Exn.raiseError
                      (\\"graphql_ppx: \\" ^
                         (\\"Expected union \\" ^
                            (\\"DogOrHuman\\" ^
                               (\\" to be an object, got \\" ^
                                  (Js.Json.stringify value)))))
                | ((Some (typename_obj))[@explicit_arity ]) ->
                    (match Js.Dict.get typename_obj \\"__typename\\" with
                     | None ->
                         Js.Exn.raiseError
                           (\\"graphql_ppx: \\" ^
                              (\\"Union \\" ^
                                 (\\"DogOrHuman\\" ^
                                    \\" is missing the __typename field\\")))
                     | ((Some (typename))[@explicit_arity ]) ->
                         (match Js.Json.decodeString typename with
                          | None ->
                              Js.Exn.raiseError
                                (\\"graphql_ppx: \\" ^
                                   (\\"Union \\" ^
                                      (\\"DogOrHuman\\" ^
                                         \\" has a __typename field that is not a string\\")))
                          | ((Some (typename))[@explicit_arity ]) ->
                              ((match typename with
                                | \\"Dog\\" ->
                                    \`Dog
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string));
                                           barkVolume =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value)
                                                  \\"barkVolume\\" in
                                              (Obj.magic value : float))
                                         }])
                                | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                         | \`Dog of _ ]))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module UnionExternalFragmentQuery =
  struct
    module DogFragment =
      struct
        let query =
          \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\"
        type t = {
          name: string ;
          barkVolume: float }
        type raw_t
        type t_Dog = t
        let parse (value : Js.Json.t) =
          let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
            [@@metaloc loc] in
          [%bs.obj
            {
              name =
                (let value = Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                 (Obj.magic value : string));
              barkVolume =
                (let value = Js.Dict.unsafeGet (Obj.magic value) \\"barkVolume\\" in
                 (Obj.magic value : float))
            }]
        let name = \\"DogFragment\\"
      end
    module Untitled1 =
      struct
        let query =
          ((\\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\" ^
              DogFragment.name)
             ^ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\")
            ^ DogFragment.query
        type raw_t
        type t =
          < dogOrHuman: [ \`Nonexhaustive  | \`Dog of DogFragment.t ]   >  Js.t
        let parse =
          (fun value ->
             let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
               [@@metaloc loc] in
             [%bs.obj
               {
                 dogOrHuman =
                   (let value =
                      Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                    match Js.Json.decodeObject value with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Expected union \\" ^
                                (\\"DogOrHuman\\" ^
                                   (\\" to be an object, got \\" ^
                                      (Js.Json.stringify value)))))
                    | ((Some (typename_obj))[@explicit_arity ]) ->
                        (match Js.Dict.get typename_obj \\"__typename\\" with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" is missing the __typename field\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             (match Js.Json.decodeString typename with
                              | None ->
                                  Js.Exn.raiseError
                                    (\\"graphql_ppx: \\" ^
                                       (\\"Union \\" ^
                                          (\\"DogOrHuman\\" ^
                                             \\" has a __typename field that is not a string\\")))
                              | ((Some (typename))[@explicit_arity ]) ->
                                  ((match typename with
                                    | \\"Dog\\" -> \`Dog (DogFragment.parse value)
                                    | _ -> \`Nonexhaustive) : [
                                                               \`Nonexhaustive 
                                                             | \`Dog of _ ]))))
               }] : Js.Json.t -> t)
        let makeVar ~f  () = f Js.Json.null
        let definition = (parse, query, makeVar)
      end
  end"
`;

exports[`Records & Legacy recursiveInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < recursiveInput: string   >  Js.t
    type t_variables = < arg: t_variables_RecursiveInput   >  Js.t
    and t_variables_RecursiveInput =
      <
        otherField: string option  ;inner: t_variables_RecursiveInput option  ;
        enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             recursiveInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"recursiveInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a -> ((Some ((serializeInputObjectRecursiveInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectRecursiveInput :
      t_variables_RecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"otherField\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## otherField)));
             (\\"inner\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some ((serializeInputObjectRecursiveInput a)))
                            [@explicit_arity ]))) b)) (inp ## inner)));
             (\\"enum\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                ((match a with
                                  | \`FIRST -> Js.Json.string \\"FIRST\\"
                                  | \`SECOND -> Js.Json.string \\"SECOND\\"
                                  | \`THIRD -> Js.Json.string \\"THIRD\\")))
                            [@explicit_arity ]))) b)) (inp ## enum)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectRecursiveInput ?otherField  ?inner  ?enum  () =
      ([%bs.obj { otherField; inner; enum }] : t_variables_RecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy scalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < variousScalars: t_variousScalars   >  Js.t
    and t_variousScalars =
      <
        nullableString: string option  ;string: string  ;nullableInt: 
                                                           int option  ;
        int: int  ;nullableFloat: float option  ;float: float  ;nullableBoolean: 
                                                                  bool option
                                                                   ;boolean: 
                                                                    bool  ;
        nullableID: string option  ;id: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             variousScalars =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableString =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None);
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       (Obj.magic value : string));
                    nullableInt =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableInt\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : int)))
                           [@explicit_arity ])
                       | None -> None);
                    int =
                      (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                       (Obj.magic value : int));
                    nullableFloat =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableFloat\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : float)))
                           [@explicit_arity ])
                       | None -> None);
                    float =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"float\\" in
                       (Obj.magic value : float));
                    nullableBoolean =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value)
                           \\"nullableBoolean\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : bool)))
                           [@explicit_arity ])
                       | None -> None);
                    boolean =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"boolean\\" in
                       (Obj.magic value : bool));
                    nullableID =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableID\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None);
                    id =
                      (let value = Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                       (Obj.magic value : string))
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy scalarsArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\"
    type raw_t
    type t = < scalarsInput: string   >  Js.t
    type t_variables =
      <
        nullableString: string option  ;string: string  ;nullableInt: 
                                                           int option  ;
        int: int  ;nullableFloat: float option  ;float: float  ;nullableBoolean: 
                                                                  bool option
                                                                   ;boolean: 
                                                                    bool  ;
        nullableID: string option  ;id: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             scalarsInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"scalarsInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableString\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## nullableString)));
             (\\"string\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## string)));(\\"nullableInt\\",
                                      (((fun a ->
                                           match a with
                                           | None -> None
                                           | ((Some (b))[@explicit_arity ])
                                               ->
                                               ((fun a ->
                                                   ((Some
                                                       ((Js.Json.number
                                                           (float_of_int a))))
                                                   [@explicit_arity ]))) b))
                                         (inp ## nullableInt)));(\\"int\\",
                                                                  (((fun a ->
                                                                    ((Some
                                                                    ((Js.Json.number
                                                                    (float_of_int
                                                                    a))))
                                                                    [@explicit_arity
                                                                    ])))
                                                                    (inp ##
                                                                    int)));
             (\\"nullableFloat\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.number a)))
                            [@explicit_arity ]))) b)) (inp ## nullableFloat)));
             (\\"float\\",
               (((fun a -> ((Some ((Js.Json.number a)))[@explicit_arity ])))
                  (inp ## float)));(\\"nullableBoolean\\",
                                     (((fun a ->
                                          match a with
                                          | None -> None
                                          | ((Some (b))[@explicit_arity ]) ->
                                              ((fun a ->
                                                  ((Some
                                                      ((Js.Json.boolean a)))
                                                  [@explicit_arity ]))) b))
                                        (inp ## nullableBoolean)));(\\"boolean\\",
                                                                    (((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.boolean
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ])))
                                                                    (inp ##
                                                                    boolean)));
             (\\"nullableID\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## nullableID)));
             (\\"id\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## id)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?nullableString  ~string  ?nullableInt  ~int 
      ?nullableFloat  ~float  ?nullableBoolean  ~boolean  ?nullableID  ~id 
      () =
      f
        (serializeVariables
           ([%bs.obj
              {
                nullableString;
                string;
                nullableInt;
                int;
                nullableFloat;
                float;
                nullableBoolean;
                boolean;
                nullableID;
                id
              }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy scalarsInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = < scalarsInput: string   >  Js.t
    type t_variables = < arg: t_variables_VariousScalarsInput   >  Js.t
    and t_variables_VariousScalarsInput =
      <
        nullableString: string option  ;string: string  ;nullableInt: 
                                                           int option  ;
        int: int  ;nullableFloat: float option  ;float: float  ;nullableBoolean: 
                                                                  bool option
                                                                   ;boolean: 
                                                                    bool  ;
        nullableID: string option  ;id: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             scalarsInput =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"scalarsInput\\" in
                (Obj.magic value : string))
           }] : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectVariousScalarsInput a)))
                    [@explicit_arity ]))) (inp ## arg)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectVariousScalarsInput :
      t_variables_VariousScalarsInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableString\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## nullableString)));
             (\\"string\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## string)));(\\"nullableInt\\",
                                      (((fun a ->
                                           match a with
                                           | None -> None
                                           | ((Some (b))[@explicit_arity ])
                                               ->
                                               ((fun a ->
                                                   ((Some
                                                       ((Js.Json.number
                                                           (float_of_int a))))
                                                   [@explicit_arity ]))) b))
                                         (inp ## nullableInt)));(\\"int\\",
                                                                  (((fun a ->
                                                                    ((Some
                                                                    ((Js.Json.number
                                                                    (float_of_int
                                                                    a))))
                                                                    [@explicit_arity
                                                                    ])))
                                                                    (inp ##
                                                                    int)));
             (\\"nullableFloat\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.number a)))
                            [@explicit_arity ]))) b)) (inp ## nullableFloat)));
             (\\"float\\",
               (((fun a -> ((Some ((Js.Json.number a)))[@explicit_arity ])))
                  (inp ## float)));(\\"nullableBoolean\\",
                                     (((fun a ->
                                          match a with
                                          | None -> None
                                          | ((Some (b))[@explicit_arity ]) ->
                                              ((fun a ->
                                                  ((Some
                                                      ((Js.Json.boolean a)))
                                                  [@explicit_arity ]))) b))
                                        (inp ## nullableBoolean)));(\\"boolean\\",
                                                                    (((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.boolean
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ])))
                                                                    (inp ##
                                                                    boolean)));
             (\\"nullableID\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) (inp ## nullableID)));
             (\\"id\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  (inp ## id)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () =
      f (serializeVariables ([%bs.obj { arg }] : t_variables))
    and makeInputObjectVariousScalarsInput ?nullableString  ~string 
      ?nullableInt  ~int  ?nullableFloat  ~float  ?nullableBoolean  ~boolean 
      ?nullableID  ~id  () =
      ([%bs.obj
         {
           nullableString;
           string;
           nullableInt;
           int;
           nullableFloat;
           float;
           nullableBoolean;
           boolean;
           nullableID;
           id
         }] : t_variables_VariousScalarsInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy skipDirectives.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < v1: t_v1  ;v2: t_v2   >  Js.t
    and t_v2 =
      < nullableString: string option  ;string: string option   >  Js.t
    and t_v1 =
      < nullableString: string option  ;string: string option   >  Js.t
    type t_variables = < var: bool   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             v1 =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"v1\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableString =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None);
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None)
                  }]);
             v2 =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"v2\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    nullableString =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None);
                    string =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ -> ((Some ((Obj.magic value : string)))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"var\\",
               (((fun a -> ((Some ((Js.Json.boolean a)))[@explicit_arity ])))
                  (inp ## var)))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~var  () =
      f (serializeVariables ([%bs.obj { var }] : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & Legacy subscription.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      <
        simpleSubscription: [ \`Dog of t_simpleSubscription_Dog 
                            | \`Human of t_simpleSubscription_Human ]   > 
        Js.t
    and t_simpleSubscription_Human = < name: string   >  Js.t
    and t_simpleSubscription_Dog = < name: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             simpleSubscription =
               (let value =
                  Js.Dict.unsafeGet (Obj.magic value) \\"simpleSubscription\\" in
                match Js.Json.decodeObject value with
                | None ->
                    Js.Exn.raiseError
                      (\\"graphql_ppx: \\" ^
                         (\\"Expected union \\" ^
                            (\\"DogOrHuman\\" ^
                               (\\" to be an object, got \\" ^
                                  (Js.Json.stringify value)))))
                | ((Some (typename_obj))[@explicit_arity ]) ->
                    (match Js.Dict.get typename_obj \\"__typename\\" with
                     | None ->
                         Js.Exn.raiseError
                           (\\"graphql_ppx: \\" ^
                              (\\"Union \\" ^
                                 (\\"DogOrHuman\\" ^
                                    \\" is missing the __typename field\\")))
                     | ((Some (typename))[@explicit_arity ]) ->
                         (match Js.Json.decodeString typename with
                          | None ->
                              Js.Exn.raiseError
                                (\\"graphql_ppx: \\" ^
                                   (\\"Union \\" ^
                                      (\\"DogOrHuman\\" ^
                                         \\" has a __typename field that is not a string\\")))
                          | ((Some (typename))[@explicit_arity ]) ->
                              ((match typename with
                                | \\"Dog\\" ->
                                    \`Dog
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string))
                                         }])
                                | \\"Human\\" ->
                                    \`Human
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string))
                                         }])
                                | typename ->
                                    Js.Exn.raiseError
                                      (\\"graphql_ppx: \\" ^
                                         (\\"Union \\" ^
                                            (\\"DogOrHuman\\" ^
                                               (\\" returned unknown type \\" ^
                                                  typename))))) : [
                                                                    \`Dog of _ 
                                                                  | \`Human of
                                                                    _ ]))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy typename.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = < first: t_first   >  Js.t
    and t_first =
      < __typename: string  ;inner: t_first_inner option   >  Js.t
    and t_first_inner =
      < __typename: string  ;inner: t_first_inner_inner option   >  Js.t
    and t_first_inner_inner = < __typename: string  ;field: string   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             first =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"first\\" in
                let value =
                  (value |> Js.Json.decodeObject) |> Js.Option.getExn
                  [@@metaloc loc] in
                [%bs.obj
                  {
                    __typename =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"__typename\\" in
                       (Obj.magic value : string));
                    inner =
                      (let value =
                         Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                       match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                       with
                       | Some _ ->
                           ((Some
                               ((let value =
                                   (value |> Js.Json.decodeObject) |>
                                     Js.Option.getExn[@@metaloc loc] in
                                 [%bs.obj
                                   {
                                     __typename =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"__typename\\" in
                                        (Obj.magic value : string));
                                     inner =
                                       (let value =
                                          Js.Dict.unsafeGet (Obj.magic value)
                                            \\"inner\\" in
                                        (match Js.toOption
                                                 (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                         with
                                         | Some _ ->
                                             ((Some
                                                 ((let value =
                                                     (value |>
                                                        Js.Json.decodeObject)
                                                       |> Js.Option.getExn
                                                     [@@metaloc loc] in
                                                   [%bs.obj
                                                     {
                                                       __typename =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value)
                                                              \\"__typename\\" in
                                                          (Obj.magic value : 
                                                            string));
                                                       field =
                                                         (let value =
                                                            Js.Dict.unsafeGet
                                                              (Obj.magic
                                                                 value)
                                                              \\"field\\" in
                                                          (Obj.magic value : 
                                                            string))
                                                     }])))
                                             [@explicit_arity ])
                                         | None -> None))
                                   }])))
                           [@explicit_arity ])
                       | None -> None)
                  }])
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy union.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      <
        dogOrHuman: [ \`Dog of t_dogOrHuman_Dog 
                    | \`Human of t_dogOrHuman_Human ]   > 
        Js.t
    and t_dogOrHuman_Human = < name: string   >  Js.t
    and t_dogOrHuman_Dog = < name: string  ;barkVolume: float   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             dogOrHuman =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                match Js.Json.decodeObject value with
                | None ->
                    Js.Exn.raiseError
                      (\\"graphql_ppx: \\" ^
                         (\\"Expected union \\" ^
                            (\\"DogOrHuman\\" ^
                               (\\" to be an object, got \\" ^
                                  (Js.Json.stringify value)))))
                | ((Some (typename_obj))[@explicit_arity ]) ->
                    (match Js.Dict.get typename_obj \\"__typename\\" with
                     | None ->
                         Js.Exn.raiseError
                           (\\"graphql_ppx: \\" ^
                              (\\"Union \\" ^
                                 (\\"DogOrHuman\\" ^
                                    \\" is missing the __typename field\\")))
                     | ((Some (typename))[@explicit_arity ]) ->
                         (match Js.Json.decodeString typename with
                          | None ->
                              Js.Exn.raiseError
                                (\\"graphql_ppx: \\" ^
                                   (\\"Union \\" ^
                                      (\\"DogOrHuman\\" ^
                                         \\" has a __typename field that is not a string\\")))
                          | ((Some (typename))[@explicit_arity ]) ->
                              ((match typename with
                                | \\"Dog\\" ->
                                    \`Dog
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string));
                                           barkVolume =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value)
                                                  \\"barkVolume\\" in
                                              (Obj.magic value : float))
                                         }])
                                | \\"Human\\" ->
                                    \`Human
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string))
                                         }])
                                | typename ->
                                    Js.Exn.raiseError
                                      (\\"graphql_ppx: \\" ^
                                         (\\"Union \\" ^
                                            (\\"DogOrHuman\\" ^
                                               (\\" returned unknown type \\" ^
                                                  typename))))) : [
                                                                    \`Dog of _ 
                                                                  | \`Human of
                                                                    _ ]))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & Legacy unionPartial.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      < dogOrHuman: [ \`Nonexhaustive  | \`Dog of t_dogOrHuman_Dog ]   >  Js.t
    and t_dogOrHuman_Dog = < name: string  ;barkVolume: float   >  Js.t
    let parse =
      (fun value ->
         let value = (value |> Js.Json.decodeObject) |> Js.Option.getExn
           [@@metaloc loc] in
         [%bs.obj
           {
             dogOrHuman =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                match Js.Json.decodeObject value with
                | None ->
                    Js.Exn.raiseError
                      (\\"graphql_ppx: \\" ^
                         (\\"Expected union \\" ^
                            (\\"DogOrHuman\\" ^
                               (\\" to be an object, got \\" ^
                                  (Js.Json.stringify value)))))
                | ((Some (typename_obj))[@explicit_arity ]) ->
                    (match Js.Dict.get typename_obj \\"__typename\\" with
                     | None ->
                         Js.Exn.raiseError
                           (\\"graphql_ppx: \\" ^
                              (\\"Union \\" ^
                                 (\\"DogOrHuman\\" ^
                                    \\" is missing the __typename field\\")))
                     | ((Some (typename))[@explicit_arity ]) ->
                         (match Js.Json.decodeString typename with
                          | None ->
                              Js.Exn.raiseError
                                (\\"graphql_ppx: \\" ^
                                   (\\"Union \\" ^
                                      (\\"DogOrHuman\\" ^
                                         \\" has a __typename field that is not a string\\")))
                          | ((Some (typename))[@explicit_arity ]) ->
                              ((match typename with
                                | \\"Dog\\" ->
                                    \`Dog
                                      (let value =
                                         (value |> Js.Json.decodeObject) |>
                                           Js.Option.getExn[@@metaloc loc] in
                                       [%bs.obj
                                         {
                                           name =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value) \\"name\\" in
                                              (Obj.magic value : string));
                                           barkVolume =
                                             (let value =
                                                Js.Dict.unsafeGet
                                                  (Obj.magic value)
                                                  \\"barkVolume\\" in
                                              (Obj.magic value : float))
                                         }])
                                | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                         | \`Dog of _ ]))))
           }] : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records & No definition argNamedQuery.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      argNamedQuery: int }
    type t_variables = {
      query: string }
    let parse =
      (fun value ->
         ({
            argNamedQuery =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"argNamedQuery\\" in
               (Obj.magic value : int))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"query\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.query))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~query  () =
      f (serializeVariables ({ query } : t_variables))
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition comment.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      nonrecursiveInput: string }
    type t_variables = {
      arg: t_variables_NonrecursiveInput }
    and t_variables_NonrecursiveInput =
      {
      field: string option ;
      enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option }
    let parse =
      (fun value ->
         ({
            nonrecursiveInput =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"nonrecursiveInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectNonrecursiveInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectNonrecursiveInput :
      t_variables_NonrecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"field\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.field));(\\"enum\\",
                                                                    (
                                                                    ((fun a
                                                                    ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((match a
                                                                    with
                                                                    | \`FIRST
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"FIRST\\"
                                                                    | \`SECOND
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"SECOND\\"
                                                                    | \`THIRD
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"THIRD\\")))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    inp.enum))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectNonrecursiveInput ?field  ?enum  () =
      ({ field; enum } : t_variables_NonrecursiveInput)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition customDecoder.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module StringOfInt = struct let parse = string_of_int
                            type t = string end
module IntOfString = struct let parse = int_of_string
                            type t = int end
module MyQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      variousScalars: t_variousScalars }
    and t_variousScalars = {
      string: IntOfString.t ;
      int: StringOfInt.t }
    let parse =
      (fun value ->
         ({
            variousScalars =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
               ({
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     IntOfString.parse (Obj.magic value : string));
                  int =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                     StringOfInt.parse (Obj.magic value : int))
                } : t_variousScalars))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition customScalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      customScalarField: t_customScalarField }
    and t_customScalarField =
      {
      nullable: Js.Json.t option ;
      nonNullable: Js.Json.t }
    type t_variables = {
      opt: Js.Json.t option ;
      req: Js.Json.t }
    let parse =
      (fun value ->
         ({
            customScalarField =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"customScalarField\\" in
               ({
                  nullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullable\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some (value))[@explicit_arity ])
                     | None -> None);
                  nonNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nonNullable\\" in
                     value)
                } : t_customScalarField))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"opt\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some (a))[@explicit_arity ]))) b))
                  inp.opt));(\\"req\\",
                              (((fun a -> ((Some (a))[@explicit_arity ])))
                                 inp.req))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?opt  ~req  () =
      f (serializeVariables ({ opt; req } : t_variables))
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition enumInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      enumInput: string }
    type t_variables = {
      arg: [ \`FIRST  | \`SECOND  | \`THIRD ] }
    let parse =
      (fun value ->
         ({
            enumInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"enumInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some
                        ((match a with
                          | \`FIRST -> Js.Json.string \\"FIRST\\"
                          | \`SECOND -> Js.Json.string \\"SECOND\\"
                          | \`THIRD -> Js.Json.string \\"THIRD\\")))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition fragmentDefinition.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module Fragments =
  struct
    let query =
      \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\"
    type t =
      {
      nullableOfNullable: string option array option ;
      nullableOfNonNullable: string array option }
    type raw_t
    type t_Lists = t
    let parse (value : Js.Json.t) =
      ({
         nullableOfNullable =
           (let value =
              Js.Dict.unsafeGet (Obj.magic value) \\"nullableOfNullable\\" in
            match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
            | Some _ ->
                ((Some
                    (((Obj.magic value) |>
                        (Js.Array.map
                           (fun value ->
                              match Js.toOption
                                      (Obj.magic value : 'a Js.Nullable.t)
                              with
                              | Some _ ->
                                  ((Some ((Obj.magic value : string)))
                                  [@explicit_arity ])
                              | None -> None)))))
                [@explicit_arity ])
            | None -> None);
         nullableOfNonNullable =
           (let value =
              Js.Dict.unsafeGet (Obj.magic value) \\"nullableOfNonNullable\\" in
            match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
            | Some _ ->
                ((Some
                    (((Obj.magic value) |>
                        (Js.Array.map
                           (fun value -> (Obj.magic value : string))))))
                [@explicit_arity ])
            | None -> None)
       } : t)
    let name = \\"ListFragment\\"
  end
module MyQuery =
  struct
    let query =
      ((((((\\"query   {\\\\nl1: lists  {\\\\n...\\" ^ Fragments.ListFragment.name) ^
             \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\")
            ^ Fragments.ListFragment.name)
           ^ \\"   \\\\n...\\")
          ^ Fragments.ListFragment.name)
         ^ \\"   \\\\n}\\\\n\\\\n}\\\\n\\")
        ^ Fragments.ListFragment.query
    type raw_t
    type t = {
      l1: Fragments.ListFragment.t ;
      l2: t_l2 }
    and t_l2 =
      {
      frag1: Fragments.ListFragment.t_Lists ;
      frag2: Fragments.ListFragment.t_Lists }
    let parse =
      (fun value ->
         ({
            l1 =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"l1\\" in
               Fragments.ListFragment.parse value);
            l2 =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"l2\\" in
               ({
                  frag1 = (Fragments.ListFragment.parse value);
                  frag2 = (Fragments.ListFragment.parse value)
                } : t_l2))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition interface.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module QueryWithFragments =
  struct
    let query =
      \\"query   {\\\\nusers  {\\\\n__typename\\\\nid  \\\\n...on AdminUser   {\\\\nname  \\\\n}\\\\n\\\\n...on AnonymousUser   {\\\\nanonymousId  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      {
      users:
        [ \`User of t_users_User  | \`AnonymousUser of t_users_AnonymousUser 
        | \`AdminUser of t_users_AdminUser ] array }
    and t_users_AdminUser = {
      id: string ;
      name: string }
    and t_users_AnonymousUser = {
      id: string ;
      anonymousId: int }
    let parse =
      (fun value ->
         ({
            users =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"users\\" in
               (Obj.magic value) |>
                 (Js.Array.map
                    (fun value ->
                       match Js.Json.decodeObject value with
                       | None ->
                           Js.Exn.raiseError
                             (\\"graphql_ppx: \\" ^
                                (\\"Expected Interface implementation \\" ^
                                   (\\"User\\" ^
                                      (\\" to be an object, got \\" ^
                                         (Js.Json.stringify value)))))
                       | ((Some (typename_obj))[@explicit_arity ]) ->
                           (match Js.Dict.get typename_obj \\"__typename\\" with
                            | None ->
                                Js.Exn.raiseError
                                  (\\"graphql_ppx: \\" ^
                                     (\\"Interface implementation\\" ^
                                        (\\"User\\" ^
                                           \\" is missing the __typename field\\")))
                            | ((Some (typename))[@explicit_arity ]) ->
                                (match Js.Json.decodeString typename with
                                 | None ->
                                     Js.Exn.raiseError
                                       (\\"graphql_ppx: \\" ^
                                          (\\"Interface implementation \\" ^
                                             (\\"User\\" ^
                                                \\" has a __typename field that is not a string\\")))
                                 | ((Some (typename))[@explicit_arity ]) ->
                                     ((match typename with
                                       | \\"AnonymousUser\\" ->
                                           \`AnonymousUser
                                             ({
                                                id =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value) \\"id\\" in
                                                   (Obj.magic value : 
                                                     string));
                                                anonymousId =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value)
                                                       \\"anonymousId\\" in
                                                   (Obj.magic value : 
                                                     int))
                                              } : t_users_User_AnonymousUser)
                                       | \\"AdminUser\\" ->
                                           \`AdminUser
                                             ({
                                                id =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value) \\"id\\" in
                                                   (Obj.magic value : 
                                                     string));
                                                name =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value)
                                                       \\"name\\" in
                                                   (Obj.magic value : 
                                                     string))
                                              } : t_users_User_AdminUser)
                                       | _ ->
                                           \`User
                                             ({
                                                id =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value) \\"id\\" in
                                                   (Obj.magic value : 
                                                     string))
                                              } : t_users_User_User)) : 
                                     [ \`User of _  | \`AnonymousUser of _ 
                                     | \`AdminUser of _ ]))))))
          } : t) : Js.Json.t -> t)
  end
module QueryWithoutFragments =
  struct
    let query = \\"query   {\\\\nusers  {\\\\n__typename\\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      users: [ \`User of t_users_User ] array }
    let parse =
      (fun value ->
         ({
            users =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"users\\" in
               (Obj.magic value) |>
                 (Js.Array.map
                    (fun value ->
                       match Js.Json.decodeObject value with
                       | None ->
                           Js.Exn.raiseError
                             (\\"graphql_ppx: \\" ^
                                (\\"Expected Interface implementation \\" ^
                                   (\\"User\\" ^
                                      (\\" to be an object, got \\" ^
                                         (Js.Json.stringify value)))))
                       | ((Some (typename_obj))[@explicit_arity ]) ->
                           (match Js.Dict.get typename_obj \\"__typename\\" with
                            | None ->
                                Js.Exn.raiseError
                                  (\\"graphql_ppx: \\" ^
                                     (\\"Interface implementation\\" ^
                                        (\\"User\\" ^
                                           \\" is missing the __typename field\\")))
                            | ((Some (typename))[@explicit_arity ]) ->
                                (match Js.Json.decodeString typename with
                                 | None ->
                                     Js.Exn.raiseError
                                       (\\"graphql_ppx: \\" ^
                                          (\\"Interface implementation \\" ^
                                             (\\"User\\" ^
                                                \\" has a __typename field that is not a string\\")))
                                 | ((Some (typename))[@explicit_arity ]) ->
                                     ((match typename with
                                       | _ ->
                                           \`User
                                             ({
                                                id =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value) \\"id\\" in
                                                   (Obj.magic value : 
                                                     string))
                                              } : t_users_User_User)) : 
                                     [ \`User of _ ]))))))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition lists.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      lists: t_lists }
    and t_lists =
      {
      nullableOfNullable: string option array option ;
      nullableOfNonNullable: string array option ;
      nonNullableOfNullable: string option array ;
      nonNullableOfNonNullable: string array }
    let parse =
      (fun value ->
         ({
            lists =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"lists\\" in
               ({
                  nullableOfNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value)
                         \\"nullableOfNullable\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (((Obj.magic value) |>
                                 (Js.Array.map
                                    (fun value ->
                                       match Js.toOption
                                               (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                       with
                                       | Some _ ->
                                           ((Some
                                               ((Obj.magic value : string)))
                                           [@explicit_arity ])
                                       | None -> None)))))
                         [@explicit_arity ])
                     | None -> None);
                  nullableOfNonNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value)
                         \\"nullableOfNonNullable\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (((Obj.magic value) |>
                                 (Js.Array.map
                                    (fun value -> (Obj.magic value : string))))))
                         [@explicit_arity ])
                     | None -> None);
                  nonNullableOfNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value)
                         \\"nonNullableOfNullable\\" in
                     (Obj.magic value) |>
                       (Js.Array.map
                          (fun value ->
                             match Js.toOption
                                     (Obj.magic value : 'a Js.Nullable.t)
                             with
                             | Some _ -> ((Some ((Obj.magic value : string)))
                                 [@explicit_arity ])
                             | None -> None)));
                  nonNullableOfNonNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value)
                         \\"nonNullableOfNonNullable\\" in
                     (Obj.magic value) |>
                       (Js.Array.map
                          (fun value -> (Obj.magic value : string))))
                } : t_lists))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition listsArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      listsInput: string }
    type t_variables =
      {
      nullableOfNullable: string option array option ;
      nullableOfNonNullable: string array option ;
      nonNullableOfNullable: string option array ;
      nonNullableOfNonNullable: string array }
    let parse =
      (fun value ->
         ({
            listsInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"listsInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableOfNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    match a with
                                                    | None -> None
                                                    | ((Some
                                                        (b))[@explicit_arity
                                                              ])
                                                        ->
                                                        ((fun a ->
                                                            ((Some
                                                                ((Js.Json.string
                                                                    a)))
                                                            [@explicit_arity
                                                              ]))) b) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b)) inp.nullableOfNullable));
             (\\"nullableOfNonNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    ((Some
                                                        ((Js.Json.string a)))
                                                    [@explicit_arity ])) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b))
                  inp.nullableOfNonNullable));(\\"nonNullableOfNullable\\",
                                                (((fun a ->
                                                     ((Some
                                                         (((a |>
                                                              (Array.map
                                                                 (fun b ->
                                                                    match 
                                                                    (fun a ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ]))) b) b
                                                                    with
                                                                    | 
                                                                    ((Some
                                                                    (c))
                                                                    [@explicit_arity
                                                                    ]) -> c
                                                                    | 
                                                                    None ->
                                                                    Js.Json.null)))
                                                             |> Js.Json.array)))
                                                     [@explicit_arity ])))
                                                   inp.nonNullableOfNullable));
             (\\"nonNullableOfNonNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            ((Some ((Js.Json.string a)))
                                            [@explicit_arity ])) b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) inp.nonNullableOfNonNullable))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?nullableOfNullable  ?nullableOfNonNullable 
      ~nonNullableOfNullable  ~nonNullableOfNonNullable  () =
      f
        (serializeVariables
           ({
              nullableOfNullable;
              nullableOfNonNullable;
              nonNullableOfNullable;
              nonNullableOfNonNullable
            } : t_variables))
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition listsInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      listsInput: string }
    type t_variables = {
      arg: t_variables_ListsInput }
    and t_variables_ListsInput =
      {
      nullableOfNullable: string option array option ;
      nullableOfNonNullable: string array option ;
      nonNullableOfNullable: string option array ;
      nonNullableOfNonNullable: string array }
    let parse =
      (fun value ->
         ({
            listsInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"listsInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a -> ((Some ((serializeInputObjectListsInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectListsInput :
      t_variables_ListsInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableOfNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    match a with
                                                    | None -> None
                                                    | ((Some
                                                        (b))[@explicit_arity
                                                              ])
                                                        ->
                                                        ((fun a ->
                                                            ((Some
                                                                ((Js.Json.string
                                                                    a)))
                                                            [@explicit_arity
                                                              ]))) b) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b)) inp.nullableOfNullable));
             (\\"nullableOfNonNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    ((Some
                                                        ((Js.Json.string a)))
                                                    [@explicit_arity ])) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b))
                  inp.nullableOfNonNullable));(\\"nonNullableOfNullable\\",
                                                (((fun a ->
                                                     ((Some
                                                         (((a |>
                                                              (Array.map
                                                                 (fun b ->
                                                                    match 
                                                                    (fun a ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ]))) b) b
                                                                    with
                                                                    | 
                                                                    ((Some
                                                                    (c))
                                                                    [@explicit_arity
                                                                    ]) -> c
                                                                    | 
                                                                    None ->
                                                                    Js.Json.null)))
                                                             |> Js.Json.array)))
                                                     [@explicit_arity ])))
                                                   inp.nonNullableOfNullable));
             (\\"nonNullableOfNonNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            ((Some ((Js.Json.string a)))
                                            [@explicit_arity ])) b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) inp.nonNullableOfNonNullable))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectListsInput ?nullableOfNullable  ?nullableOfNonNullable
       ~nonNullableOfNullable  ~nonNullableOfNonNullable  () =
      ({
         nullableOfNullable;
         nullableOfNonNullable;
         nonNullableOfNullable;
         nonNullableOfNonNullable
       } : t_variables_ListsInput)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition mutation.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      mutationWithError: t_mutationWithError }
    and t_mutationWithError =
      {
      value: t_mutationWithError_value option ;
      errors: t_mutationWithError_errors array option }
    and t_mutationWithError_errors =
      {
      field: [ \`FIRST  | \`SECOND  | \`THIRD ] ;
      message: string }
    and t_mutationWithError_value = {
      stringField: string }
    let parse =
      (fun value ->
         ({
            mutationWithError =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"mutationWithError\\" in
               ({
                  value =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"value\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (({
                                 stringField =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"stringField\\" in
                                    (Obj.magic value : string))
                               } : t_mutationWithError_value)))
                         [@explicit_arity ])
                     | None -> None);
                  errors =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"errors\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (((Obj.magic value) |>
                                 (Js.Array.map
                                    (fun value ->
                                       ({
                                          field =
                                            (let value =
                                               Js.Dict.unsafeGet
                                                 (Obj.magic value) \\"field\\" in
                                             match Js.Json.decodeString value
                                             with
                                             | None ->
                                                 Js.Exn.raiseError
                                                   (\\"graphql_ppx: \\" ^
                                                      (\\"Expected enum value for \\"
                                                         ^
                                                         (\\"SampleField\\" ^
                                                            (\\", got \\" ^
                                                               (Js.Json.stringify
                                                                  value)))))
                                             | ((Some
                                                 (value))[@explicit_arity ])
                                                 ->
                                                 ((match value with
                                                   | \\"FIRST\\" -> \`FIRST
                                                   | \\"SECOND\\" -> \`SECOND
                                                   | \\"THIRD\\" -> \`THIRD
                                                   | _ ->
                                                       Js.Exn.raiseError
                                                         (\\"graphql_ppx: \\" ^
                                                            (\\"Unknown enum variant for \\"
                                                               ^
                                                               (\\"SampleField\\"
                                                                  ^
                                                                  (\\": \\" ^
                                                                    value))))) : 
                                                 [ \`FIRST  | \`SECOND 
                                                 | \`THIRD ]));
                                          message =
                                            (let value =
                                               Js.Dict.unsafeGet
                                                 (Obj.magic value) \\"message\\" in
                                             (Obj.magic value : string))
                                        } : t_mutationWithError_errors))))))
                         [@explicit_arity ])
                     | None -> None)
                } : t_mutationWithError))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition mutationWithArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      optionalInputArgs: string }
    type t_variables = {
      required: string }
    let parse =
      (fun value ->
         ({
            optionalInputArgs =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"optionalInputArgs\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"required\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.required))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~required  () =
      f (serializeVariables ({ required } : t_variables))
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition nested.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
type record = {
  f1: string ;
  f2: string }
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      first: t_first ;
      second: t_second }
    and t_second = {
      inner: t_second_inner option }
    and t_second_inner = {
      inner: t_second_inner_inner option }
    and t_second_inner_inner = {
      f1: string ;
      f2: string }
    and t_first = {
      inner: t_first_inner option }
    and t_first_inner = {
      inner: t_first_inner_inner option }
    and t_first_inner_inner = {
      field: string }
    let parse =
      (fun value ->
         ({
            first =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"first\\" in
               ({
                  inner =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (({
                                 inner =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"inner\\" in
                                    (match Js.toOption
                                             (Obj.magic value : 'a
                                                                  Js.Nullable.t)
                                     with
                                     | Some _ ->
                                         ((Some
                                             (({
                                                 field =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"field\\" in
                                                    (Obj.magic value : 
                                                      string))
                                               } : t_first_inner_inner)))
                                         [@explicit_arity ])
                                     | None -> None))
                               } : t_first_inner)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_first));
            second =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"second\\" in
               ({
                  inner =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (({
                                 inner =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"inner\\" in
                                    (match Js.toOption
                                             (Obj.magic value : 'a
                                                                  Js.Nullable.t)
                                     with
                                     | Some _ ->
                                         ((Some
                                             (({
                                                 f1 =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"f1\\" in
                                                    (Obj.magic value : 
                                                      string));
                                                 f2 =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"f2\\" in
                                                    (Obj.magic value : 
                                                      string))
                                               } : t_second_inner_inner)))
                                         [@explicit_arity ])
                                     | None -> None))
                               } : t_second_inner)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_second))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition nonrecursiveInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      nonrecursiveInput: string }
    type t_variables = {
      arg: t_variables_NonrecursiveInput }
    and t_variables_NonrecursiveInput =
      {
      field: string option ;
      enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option }
    let parse =
      (fun value ->
         ({
            nonrecursiveInput =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"nonrecursiveInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectNonrecursiveInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectNonrecursiveInput :
      t_variables_NonrecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"field\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.field));(\\"enum\\",
                                                                    (
                                                                    ((fun a
                                                                    ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((match a
                                                                    with
                                                                    | \`FIRST
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"FIRST\\"
                                                                    | \`SECOND
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"SECOND\\"
                                                                    | \`THIRD
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"THIRD\\")))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    inp.enum))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectNonrecursiveInput ?field  ?enum  () =
      ({ field; enum } : t_variables_NonrecursiveInput)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition pokedexApolloMode.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      pokemon: t_pokemon option }
    and t_pokemon = {
      id: string ;
      name: string option }
    let parse =
      (fun value ->
         ({
            pokemon =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"pokemon\\" in
               match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
               | Some _ ->
                   ((Some
                       (({
                           id =
                             (let value =
                                Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                              (Obj.magic value : string));
                           name =
                             (let value =
                                Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                              (match Js.toOption
                                       (Obj.magic value : 'a Js.Nullable.t)
                               with
                               | Some _ ->
                                   ((Some ((Obj.magic value : string)))
                                   [@explicit_arity ])
                               | None -> None))
                         } : t_pokemon)))
                   [@explicit_arity ])
               | None -> None)
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition pokedexScalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      pokemon: t_pokemon option }
    and t_pokemon = {
      id: string ;
      name: string option }
    type t_variables = {
      id: string option ;
      name: string option }
    let parse =
      (fun value ->
         ({
            pokemon =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"pokemon\\" in
               match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
               | Some _ ->
                   ((Some
                       (({
                           id =
                             (let value =
                                Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                              (Obj.magic value : string));
                           name =
                             (let value =
                                Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                              (match Js.toOption
                                       (Obj.magic value : 'a Js.Nullable.t)
                               with
                               | Some _ ->
                                   ((Some ((Obj.magic value : string)))
                                   [@explicit_arity ])
                               | None -> None))
                         } : t_pokemon)))
                   [@explicit_arity ])
               | None -> None)
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"id\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.id));(\\"name\\",
                                                                 (((fun a ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    inp.name))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?id  ?name  () =
      f (serializeVariables ({ id; name } : t_variables))
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition record.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
type scalars = {
  string: string ;
  int: int }
type dog = {
  name: string ;
  barkVolume: float }
type oneFieldQuery = {
  nullableString: string option }
module MyQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      variousScalars: t_variousScalars }
    and t_variousScalars = {
      string: string ;
      int: int }
    let parse =
      (fun value ->
         ({
            variousScalars =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
               ({
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     (Obj.magic value : string));
                  int =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                     (Obj.magic value : int))
                } : t_variousScalars))
          } : t) : Js.Json.t -> t)
  end
module OneFieldQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      variousScalars: t_variousScalars }
    and t_variousScalars = {
      nullableString: string option }
    let parse =
      (fun value ->
         ({
            variousScalars =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
               ({
                  nullableString =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_variousScalars))
          } : t) : Js.Json.t -> t)
  end
module ExternalFragmentQuery =
  struct
    module Fragment =
      struct
        let query =
          \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\"
        type t = {
          string: string ;
          int: int }
        type raw_t
        type t_VariousScalars = t
        let parse (value : Js.Json.t) =
          ({
             string =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                (Obj.magic value : string));
             int =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                (Obj.magic value : int))
           } : t)
        let name = \\"Fragment\\"
      end
    module Untitled1 =
      struct
        let query =
          ((\\"query   {\\\\nvariousScalars  {\\\\n...\\" ^ Fragment.name) ^
             \\"   \\\\n}\\\\n\\\\n}\\\\n\\")
            ^ Fragment.query
        type raw_t
        type t = {
          variousScalars: Fragment.t }
        let parse =
          (fun value ->
             ({
                variousScalars =
                  (let value =
                     Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                   Fragment.parse value)
              } : t) : Js.Json.t -> t)
      end
  end
module InlineFragmentQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      dogOrHuman: [ \`Nonexhaustive  | \`Dog of t_dogOrHuman_Dog ] }
    and t_dogOrHuman_Dog = {
      name: string ;
      barkVolume: float }
    let parse =
      (fun value ->
         ({
            dogOrHuman =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
               match Js.Json.decodeObject value with
               | None ->
                   Js.Exn.raiseError
                     (\\"graphql_ppx: \\" ^
                        (\\"Expected union \\" ^
                           (\\"DogOrHuman\\" ^
                              (\\" to be an object, got \\" ^
                                 (Js.Json.stringify value)))))
               | ((Some (typename_obj))[@explicit_arity ]) ->
                   (match Js.Dict.get typename_obj \\"__typename\\" with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Union \\" ^
                                (\\"DogOrHuman\\" ^
                                   \\" is missing the __typename field\\")))
                    | ((Some (typename))[@explicit_arity ]) ->
                        (match Js.Json.decodeString typename with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" has a __typename field that is not a string\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             ((match typename with
                               | \\"Dog\\" ->
                                   \`Dog
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string));
                                        barkVolume =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"barkVolume\\" in
                                           (Obj.magic value : float))
                                      } : t_dogOrHuman_Dog)
                               | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                        | \`Dog of _ ]))))
          } : t) : Js.Json.t -> t)
  end
module UnionExternalFragmentQuery =
  struct
    module DogFragment =
      struct
        let query =
          \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\"
        type t = {
          name: string ;
          barkVolume: float }
        type raw_t
        type t_Dog = t
        let parse (value : Js.Json.t) =
          ({
             name =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                (Obj.magic value : string));
             barkVolume =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"barkVolume\\" in
                (Obj.magic value : float))
           } : t)
        let name = \\"DogFragment\\"
      end
    module Untitled1 =
      struct
        let query =
          ((\\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\" ^
              DogFragment.name)
             ^ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\")
            ^ DogFragment.query
        type raw_t
        type t = {
          dogOrHuman: [ \`Nonexhaustive  | \`Dog of DogFragment.t ] }
        let parse =
          (fun value ->
             ({
                dogOrHuman =
                  (let value =
                     Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                   match Js.Json.decodeObject value with
                   | None ->
                       Js.Exn.raiseError
                         (\\"graphql_ppx: \\" ^
                            (\\"Expected union \\" ^
                               (\\"DogOrHuman\\" ^
                                  (\\" to be an object, got \\" ^
                                     (Js.Json.stringify value)))))
                   | ((Some (typename_obj))[@explicit_arity ]) ->
                       (match Js.Dict.get typename_obj \\"__typename\\" with
                        | None ->
                            Js.Exn.raiseError
                              (\\"graphql_ppx: \\" ^
                                 (\\"Union \\" ^
                                    (\\"DogOrHuman\\" ^
                                       \\" is missing the __typename field\\")))
                        | ((Some (typename))[@explicit_arity ]) ->
                            (match Js.Json.decodeString typename with
                             | None ->
                                 Js.Exn.raiseError
                                   (\\"graphql_ppx: \\" ^
                                      (\\"Union \\" ^
                                         (\\"DogOrHuman\\" ^
                                            \\" has a __typename field that is not a string\\")))
                             | ((Some (typename))[@explicit_arity ]) ->
                                 ((match typename with
                                   | \\"Dog\\" -> \`Dog (DogFragment.parse value)
                                   | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                            | \`Dog of _ ]))))
              } : t) : Js.Json.t -> t)
      end
  end"
`;

exports[`Records & No definition recursiveInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      recursiveInput: string }
    type t_variables = {
      arg: t_variables_RecursiveInput }
    and t_variables_RecursiveInput =
      {
      otherField: string option ;
      inner: t_variables_RecursiveInput option ;
      enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option }
    let parse =
      (fun value ->
         ({
            recursiveInput =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"recursiveInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a -> ((Some ((serializeInputObjectRecursiveInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectRecursiveInput :
      t_variables_RecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"otherField\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.otherField));
             (\\"inner\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some ((serializeInputObjectRecursiveInput a)))
                            [@explicit_arity ]))) b)) inp.inner));(\\"enum\\",
                                                                    (
                                                                    ((fun a
                                                                    ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((match a
                                                                    with
                                                                    | \`FIRST
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"FIRST\\"
                                                                    | \`SECOND
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"SECOND\\"
                                                                    | \`THIRD
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"THIRD\\")))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    inp.enum))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectRecursiveInput ?otherField  ?inner  ?enum  () =
      ({ otherField; inner; enum } : t_variables_RecursiveInput)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition scalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      variousScalars: t_variousScalars }
    and t_variousScalars =
      {
      nullableString: string option ;
      string: string ;
      nullableInt: int option ;
      int: int ;
      nullableFloat: float option ;
      float: float ;
      nullableBoolean: bool option ;
      boolean: bool ;
      nullableID: string option ;
      id: string }
    let parse =
      (fun value ->
         ({
            variousScalars =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
               ({
                  nullableString =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None);
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     (Obj.magic value : string));
                  nullableInt =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableInt\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : int)))
                         [@explicit_arity ])
                     | None -> None);
                  int =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                     (Obj.magic value : int));
                  nullableFloat =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableFloat\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : float)))
                         [@explicit_arity ])
                     | None -> None);
                  float =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"float\\" in
                     (Obj.magic value : float));
                  nullableBoolean =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableBoolean\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : bool)))
                         [@explicit_arity ])
                     | None -> None);
                  boolean =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"boolean\\" in
                     (Obj.magic value : bool));
                  nullableID =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableID\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None);
                  id =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                     (Obj.magic value : string))
                } : t_variousScalars))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition scalarsArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      scalarsInput: string }
    type t_variables =
      {
      nullableString: string option ;
      string: string ;
      nullableInt: int option ;
      int: int ;
      nullableFloat: float option ;
      float: float ;
      nullableBoolean: bool option ;
      boolean: bool ;
      nullableID: string option ;
      id: string }
    let parse =
      (fun value ->
         ({
            scalarsInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"scalarsInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableString\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.nullableString));
             (\\"string\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.string));(\\"nullableInt\\",
                                 (((fun a ->
                                      match a with
                                      | None -> None
                                      | ((Some (b))[@explicit_arity ]) ->
                                          ((fun a ->
                                              ((Some
                                                  ((Js.Json.number
                                                      (float_of_int a))))
                                              [@explicit_arity ]))) b))
                                    inp.nullableInt));(\\"int\\",
                                                        (((fun a ->
                                                             ((Some
                                                                 ((Js.Json.number
                                                                    (float_of_int
                                                                    a))))
                                                             [@explicit_arity
                                                               ]))) inp.int));
             (\\"nullableFloat\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.number a)))
                            [@explicit_arity ]))) b)) inp.nullableFloat));
             (\\"float\\",
               (((fun a -> ((Some ((Js.Json.number a)))[@explicit_arity ])))
                  inp.float));(\\"nullableBoolean\\",
                                (((fun a ->
                                     match a with
                                     | None -> None
                                     | ((Some (b))[@explicit_arity ]) ->
                                         ((fun a ->
                                             ((Some ((Js.Json.boolean a)))
                                             [@explicit_arity ]))) b))
                                   inp.nullableBoolean));(\\"boolean\\",
                                                           (((fun a ->
                                                                ((Some
                                                                    ((Js.Json.boolean
                                                                    a)))
                                                                [@explicit_arity
                                                                  ])))
                                                              inp.boolean));
             (\\"nullableID\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.nullableID));
             (\\"id\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.id))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?nullableString  ~string  ?nullableInt  ~int 
      ?nullableFloat  ~float  ?nullableBoolean  ~boolean  ?nullableID  ~id 
      () =
      f
        (serializeVariables
           ({
              nullableString;
              string;
              nullableInt;
              int;
              nullableFloat;
              float;
              nullableBoolean;
              boolean;
              nullableID;
              id
            } : t_variables))
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition scalarsInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      scalarsInput: string }
    type t_variables = {
      arg: t_variables_VariousScalarsInput }
    and t_variables_VariousScalarsInput =
      {
      nullableString: string option ;
      string: string ;
      nullableInt: int option ;
      int: int ;
      nullableFloat: float option ;
      float: float ;
      nullableBoolean: bool option ;
      boolean: bool ;
      nullableID: string option ;
      id: string }
    let parse =
      (fun value ->
         ({
            scalarsInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"scalarsInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectVariousScalarsInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectVariousScalarsInput :
      t_variables_VariousScalarsInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableString\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.nullableString));
             (\\"string\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.string));(\\"nullableInt\\",
                                 (((fun a ->
                                      match a with
                                      | None -> None
                                      | ((Some (b))[@explicit_arity ]) ->
                                          ((fun a ->
                                              ((Some
                                                  ((Js.Json.number
                                                      (float_of_int a))))
                                              [@explicit_arity ]))) b))
                                    inp.nullableInt));(\\"int\\",
                                                        (((fun a ->
                                                             ((Some
                                                                 ((Js.Json.number
                                                                    (float_of_int
                                                                    a))))
                                                             [@explicit_arity
                                                               ]))) inp.int));
             (\\"nullableFloat\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.number a)))
                            [@explicit_arity ]))) b)) inp.nullableFloat));
             (\\"float\\",
               (((fun a -> ((Some ((Js.Json.number a)))[@explicit_arity ])))
                  inp.float));(\\"nullableBoolean\\",
                                (((fun a ->
                                     match a with
                                     | None -> None
                                     | ((Some (b))[@explicit_arity ]) ->
                                         ((fun a ->
                                             ((Some ((Js.Json.boolean a)))
                                             [@explicit_arity ]))) b))
                                   inp.nullableBoolean));(\\"boolean\\",
                                                           (((fun a ->
                                                                ((Some
                                                                    ((Js.Json.boolean
                                                                    a)))
                                                                [@explicit_arity
                                                                  ])))
                                                              inp.boolean));
             (\\"nullableID\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.nullableID));
             (\\"id\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.id))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectVariousScalarsInput ?nullableString  ~string 
      ?nullableInt  ~int  ?nullableFloat  ~float  ?nullableBoolean  ~boolean 
      ?nullableID  ~id  () =
      ({
         nullableString;
         string;
         nullableInt;
         int;
         nullableFloat;
         float;
         nullableBoolean;
         boolean;
         nullableID;
         id
       } : t_variables_VariousScalarsInput)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition skipDirectives.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      v1: t_v1 ;
      v2: t_v2 }
    and t_v2 = {
      nullableString: string option ;
      string: string option }
    and t_v1 = {
      nullableString: string option ;
      string: string option }
    type t_variables = {
      var: bool }
    let parse =
      (fun value ->
         ({
            v1 =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"v1\\" in
               ({
                  nullableString =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None);
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_v1));
            v2 =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"v2\\" in
               ({
                  nullableString =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None);
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_v2))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"var\\",
               (((fun a -> ((Some ((Js.Json.boolean a)))[@explicit_arity ])))
                  inp.var))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~var  () = f (serializeVariables ({ var } : t_variables))
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records & No definition subscription.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      {
      simpleSubscription:
        [ \`Dog of t_simpleSubscription_Dog 
        | \`Human of t_simpleSubscription_Human ] }
    and t_simpleSubscription_Human = {
      name: string }
    and t_simpleSubscription_Dog = {
      name: string }
    let parse =
      (fun value ->
         ({
            simpleSubscription =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"simpleSubscription\\" in
               match Js.Json.decodeObject value with
               | None ->
                   Js.Exn.raiseError
                     (\\"graphql_ppx: \\" ^
                        (\\"Expected union \\" ^
                           (\\"DogOrHuman\\" ^
                              (\\" to be an object, got \\" ^
                                 (Js.Json.stringify value)))))
               | ((Some (typename_obj))[@explicit_arity ]) ->
                   (match Js.Dict.get typename_obj \\"__typename\\" with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Union \\" ^
                                (\\"DogOrHuman\\" ^
                                   \\" is missing the __typename field\\")))
                    | ((Some (typename))[@explicit_arity ]) ->
                        (match Js.Json.decodeString typename with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" has a __typename field that is not a string\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             ((match typename with
                               | \\"Dog\\" ->
                                   \`Dog
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string))
                                      } : t_simpleSubscription_Dog)
                               | \\"Human\\" ->
                                   \`Human
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string))
                                      } : t_simpleSubscription_Human)
                               | typename ->
                                   Js.Exn.raiseError
                                     (\\"graphql_ppx: \\" ^
                                        (\\"Union \\" ^
                                           (\\"DogOrHuman\\" ^
                                              (\\" returned unknown type \\" ^
                                                 typename))))) : [ \`Dog of _ 
                                                                 | \`Human of
                                                                    _ ]))))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition typename.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      first: t_first }
    and t_first = {
      __typename: string ;
      inner: t_first_inner option }
    and t_first_inner =
      {
      __typename: string ;
      inner: t_first_inner_inner option }
    and t_first_inner_inner = {
      __typename: string ;
      field: string }
    let parse =
      (fun value ->
         ({
            first =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"first\\" in
               ({
                  __typename =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"__typename\\" in
                     (Obj.magic value : string));
                  inner =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (({
                                 __typename =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"__typename\\" in
                                    (Obj.magic value : string));
                                 inner =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"inner\\" in
                                    (match Js.toOption
                                             (Obj.magic value : 'a
                                                                  Js.Nullable.t)
                                     with
                                     | Some _ ->
                                         ((Some
                                             (({
                                                 __typename =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"__typename\\" in
                                                    (Obj.magic value : 
                                                      string));
                                                 field =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"field\\" in
                                                    (Obj.magic value : 
                                                      string))
                                               } : t_first_inner_inner)))
                                         [@explicit_arity ])
                                     | None -> None))
                               } : t_first_inner)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_first))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition union.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      {
      dogOrHuman:
        [ \`Dog of t_dogOrHuman_Dog  | \`Human of t_dogOrHuman_Human ] }
    and t_dogOrHuman_Human = {
      name: string }
    and t_dogOrHuman_Dog = {
      name: string ;
      barkVolume: float }
    let parse =
      (fun value ->
         ({
            dogOrHuman =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
               match Js.Json.decodeObject value with
               | None ->
                   Js.Exn.raiseError
                     (\\"graphql_ppx: \\" ^
                        (\\"Expected union \\" ^
                           (\\"DogOrHuman\\" ^
                              (\\" to be an object, got \\" ^
                                 (Js.Json.stringify value)))))
               | ((Some (typename_obj))[@explicit_arity ]) ->
                   (match Js.Dict.get typename_obj \\"__typename\\" with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Union \\" ^
                                (\\"DogOrHuman\\" ^
                                   \\" is missing the __typename field\\")))
                    | ((Some (typename))[@explicit_arity ]) ->
                        (match Js.Json.decodeString typename with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" has a __typename field that is not a string\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             ((match typename with
                               | \\"Dog\\" ->
                                   \`Dog
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string));
                                        barkVolume =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"barkVolume\\" in
                                           (Obj.magic value : float))
                                      } : t_dogOrHuman_Dog)
                               | \\"Human\\" ->
                                   \`Human
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string))
                                      } : t_dogOrHuman_Human)
                               | typename ->
                                   Js.Exn.raiseError
                                     (\\"graphql_ppx: \\" ^
                                        (\\"Union \\" ^
                                           (\\"DogOrHuman\\" ^
                                              (\\" returned unknown type \\" ^
                                                 typename))))) : [ \`Dog of _ 
                                                                 | \`Human of
                                                                    _ ]))))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records & No definition unionPartial.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      dogOrHuman: [ \`Nonexhaustive  | \`Dog of t_dogOrHuman_Dog ] }
    and t_dogOrHuman_Dog = {
      name: string ;
      barkVolume: float }
    let parse =
      (fun value ->
         ({
            dogOrHuman =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
               match Js.Json.decodeObject value with
               | None ->
                   Js.Exn.raiseError
                     (\\"graphql_ppx: \\" ^
                        (\\"Expected union \\" ^
                           (\\"DogOrHuman\\" ^
                              (\\" to be an object, got \\" ^
                                 (Js.Json.stringify value)))))
               | ((Some (typename_obj))[@explicit_arity ]) ->
                   (match Js.Dict.get typename_obj \\"__typename\\" with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Union \\" ^
                                (\\"DogOrHuman\\" ^
                                   \\" is missing the __typename field\\")))
                    | ((Some (typename))[@explicit_arity ]) ->
                        (match Js.Json.decodeString typename with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" has a __typename field that is not a string\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             ((match typename with
                               | \\"Dog\\" ->
                                   \`Dog
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string));
                                        barkVolume =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"barkVolume\\" in
                                           (Obj.magic value : float))
                                      } : t_dogOrHuman_Dog)
                               | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                        | \`Dog of _ ]))))
          } : t) : Js.Json.t -> t)
  end"
`;

exports[`Records argNamedQuery.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      argNamedQuery: int }
    type t_variables = {
      query: string }
    let parse =
      (fun value ->
         ({
            argNamedQuery =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"argNamedQuery\\" in
               (Obj.magic value : int))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"query\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.query))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~query  () =
      f (serializeVariables ({ query } : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records comment.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      nonrecursiveInput: string }
    type t_variables = {
      arg: t_variables_NonrecursiveInput }
    and t_variables_NonrecursiveInput =
      {
      field: string option ;
      enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option }
    let parse =
      (fun value ->
         ({
            nonrecursiveInput =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"nonrecursiveInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectNonrecursiveInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectNonrecursiveInput :
      t_variables_NonrecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"field\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.field));(\\"enum\\",
                                                                    (
                                                                    ((fun a
                                                                    ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((match a
                                                                    with
                                                                    | \`FIRST
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"FIRST\\"
                                                                    | \`SECOND
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"SECOND\\"
                                                                    | \`THIRD
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"THIRD\\")))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    inp.enum))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectNonrecursiveInput ?field  ?enum  () =
      ({ field; enum } : t_variables_NonrecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records customDecoder.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module StringOfInt = struct let parse = string_of_int
                            type t = string end
module IntOfString = struct let parse = int_of_string
                            type t = int end
module MyQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      variousScalars: t_variousScalars }
    and t_variousScalars = {
      string: IntOfString.t ;
      int: StringOfInt.t }
    let parse =
      (fun value ->
         ({
            variousScalars =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
               ({
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     IntOfString.parse (Obj.magic value : string));
                  int =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                     StringOfInt.parse (Obj.magic value : int))
                } : t_variousScalars))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records customScalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      customScalarField: t_customScalarField }
    and t_customScalarField =
      {
      nullable: Js.Json.t option ;
      nonNullable: Js.Json.t }
    type t_variables = {
      opt: Js.Json.t option ;
      req: Js.Json.t }
    let parse =
      (fun value ->
         ({
            customScalarField =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"customScalarField\\" in
               ({
                  nullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullable\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some (value))[@explicit_arity ])
                     | None -> None);
                  nonNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nonNullable\\" in
                     value)
                } : t_customScalarField))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"opt\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some (a))[@explicit_arity ]))) b))
                  inp.opt));(\\"req\\",
                              (((fun a -> ((Some (a))[@explicit_arity ])))
                                 inp.req))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?opt  ~req  () =
      f (serializeVariables ({ opt; req } : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records enumInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      enumInput: string }
    type t_variables = {
      arg: [ \`FIRST  | \`SECOND  | \`THIRD ] }
    let parse =
      (fun value ->
         ({
            enumInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"enumInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some
                        ((match a with
                          | \`FIRST -> Js.Json.string \\"FIRST\\"
                          | \`SECOND -> Js.Json.string \\"SECOND\\"
                          | \`THIRD -> Js.Json.string \\"THIRD\\")))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records fragmentDefinition.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module Fragments =
  struct
    let query =
      \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\"
    type t =
      {
      nullableOfNullable: string option array option ;
      nullableOfNonNullable: string array option }
    type raw_t
    type t_Lists = t
    let parse (value : Js.Json.t) =
      ({
         nullableOfNullable =
           (let value =
              Js.Dict.unsafeGet (Obj.magic value) \\"nullableOfNullable\\" in
            match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
            | Some _ ->
                ((Some
                    (((Obj.magic value) |>
                        (Js.Array.map
                           (fun value ->
                              match Js.toOption
                                      (Obj.magic value : 'a Js.Nullable.t)
                              with
                              | Some _ ->
                                  ((Some ((Obj.magic value : string)))
                                  [@explicit_arity ])
                              | None -> None)))))
                [@explicit_arity ])
            | None -> None);
         nullableOfNonNullable =
           (let value =
              Js.Dict.unsafeGet (Obj.magic value) \\"nullableOfNonNullable\\" in
            match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
            | Some _ ->
                ((Some
                    (((Obj.magic value) |>
                        (Js.Array.map
                           (fun value -> (Obj.magic value : string))))))
                [@explicit_arity ])
            | None -> None)
       } : t)
    let name = \\"ListFragment\\"
  end
module MyQuery =
  struct
    let query =
      ((((((\\"query   {\\\\nl1: lists  {\\\\n...\\" ^ Fragments.ListFragment.name) ^
             \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\")
            ^ Fragments.ListFragment.name)
           ^ \\"   \\\\n...\\")
          ^ Fragments.ListFragment.name)
         ^ \\"   \\\\n}\\\\n\\\\n}\\\\n\\")
        ^ Fragments.ListFragment.query
    type raw_t
    type t = {
      l1: Fragments.ListFragment.t ;
      l2: t_l2 }
    and t_l2 =
      {
      frag1: Fragments.ListFragment.t_Lists ;
      frag2: Fragments.ListFragment.t_Lists }
    let parse =
      (fun value ->
         ({
            l1 =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"l1\\" in
               Fragments.ListFragment.parse value);
            l2 =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"l2\\" in
               ({
                  frag1 = (Fragments.ListFragment.parse value);
                  frag2 = (Fragments.ListFragment.parse value)
                } : t_l2))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records interface.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module QueryWithFragments =
  struct
    let query =
      \\"query   {\\\\nusers  {\\\\n__typename\\\\nid  \\\\n...on AdminUser   {\\\\nname  \\\\n}\\\\n\\\\n...on AnonymousUser   {\\\\nanonymousId  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      {
      users:
        [ \`User of t_users_User  | \`AnonymousUser of t_users_AnonymousUser 
        | \`AdminUser of t_users_AdminUser ] array }
    and t_users_AdminUser = {
      id: string ;
      name: string }
    and t_users_AnonymousUser = {
      id: string ;
      anonymousId: int }
    let parse =
      (fun value ->
         ({
            users =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"users\\" in
               (Obj.magic value) |>
                 (Js.Array.map
                    (fun value ->
                       match Js.Json.decodeObject value with
                       | None ->
                           Js.Exn.raiseError
                             (\\"graphql_ppx: \\" ^
                                (\\"Expected Interface implementation \\" ^
                                   (\\"User\\" ^
                                      (\\" to be an object, got \\" ^
                                         (Js.Json.stringify value)))))
                       | ((Some (typename_obj))[@explicit_arity ]) ->
                           (match Js.Dict.get typename_obj \\"__typename\\" with
                            | None ->
                                Js.Exn.raiseError
                                  (\\"graphql_ppx: \\" ^
                                     (\\"Interface implementation\\" ^
                                        (\\"User\\" ^
                                           \\" is missing the __typename field\\")))
                            | ((Some (typename))[@explicit_arity ]) ->
                                (match Js.Json.decodeString typename with
                                 | None ->
                                     Js.Exn.raiseError
                                       (\\"graphql_ppx: \\" ^
                                          (\\"Interface implementation \\" ^
                                             (\\"User\\" ^
                                                \\" has a __typename field that is not a string\\")))
                                 | ((Some (typename))[@explicit_arity ]) ->
                                     ((match typename with
                                       | \\"AnonymousUser\\" ->
                                           \`AnonymousUser
                                             ({
                                                id =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value) \\"id\\" in
                                                   (Obj.magic value : 
                                                     string));
                                                anonymousId =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value)
                                                       \\"anonymousId\\" in
                                                   (Obj.magic value : 
                                                     int))
                                              } : t_users_User_AnonymousUser)
                                       | \\"AdminUser\\" ->
                                           \`AdminUser
                                             ({
                                                id =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value) \\"id\\" in
                                                   (Obj.magic value : 
                                                     string));
                                                name =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value)
                                                       \\"name\\" in
                                                   (Obj.magic value : 
                                                     string))
                                              } : t_users_User_AdminUser)
                                       | _ ->
                                           \`User
                                             ({
                                                id =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value) \\"id\\" in
                                                   (Obj.magic value : 
                                                     string))
                                              } : t_users_User_User)) : 
                                     [ \`User of _  | \`AnonymousUser of _ 
                                     | \`AdminUser of _ ]))))))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module QueryWithoutFragments =
  struct
    let query = \\"query   {\\\\nusers  {\\\\n__typename\\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      users: [ \`User of t_users_User ] array }
    let parse =
      (fun value ->
         ({
            users =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"users\\" in
               (Obj.magic value) |>
                 (Js.Array.map
                    (fun value ->
                       match Js.Json.decodeObject value with
                       | None ->
                           Js.Exn.raiseError
                             (\\"graphql_ppx: \\" ^
                                (\\"Expected Interface implementation \\" ^
                                   (\\"User\\" ^
                                      (\\" to be an object, got \\" ^
                                         (Js.Json.stringify value)))))
                       | ((Some (typename_obj))[@explicit_arity ]) ->
                           (match Js.Dict.get typename_obj \\"__typename\\" with
                            | None ->
                                Js.Exn.raiseError
                                  (\\"graphql_ppx: \\" ^
                                     (\\"Interface implementation\\" ^
                                        (\\"User\\" ^
                                           \\" is missing the __typename field\\")))
                            | ((Some (typename))[@explicit_arity ]) ->
                                (match Js.Json.decodeString typename with
                                 | None ->
                                     Js.Exn.raiseError
                                       (\\"graphql_ppx: \\" ^
                                          (\\"Interface implementation \\" ^
                                             (\\"User\\" ^
                                                \\" has a __typename field that is not a string\\")))
                                 | ((Some (typename))[@explicit_arity ]) ->
                                     ((match typename with
                                       | _ ->
                                           \`User
                                             ({
                                                id =
                                                  (let value =
                                                     Js.Dict.unsafeGet
                                                       (Obj.magic value) \\"id\\" in
                                                   (Obj.magic value : 
                                                     string))
                                              } : t_users_User_User)) : 
                                     [ \`User of _ ]))))))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records lists.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      lists: t_lists }
    and t_lists =
      {
      nullableOfNullable: string option array option ;
      nullableOfNonNullable: string array option ;
      nonNullableOfNullable: string option array ;
      nonNullableOfNonNullable: string array }
    let parse =
      (fun value ->
         ({
            lists =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"lists\\" in
               ({
                  nullableOfNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value)
                         \\"nullableOfNullable\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (((Obj.magic value) |>
                                 (Js.Array.map
                                    (fun value ->
                                       match Js.toOption
                                               (Obj.magic value : 'a
                                                                    Js.Nullable.t)
                                       with
                                       | Some _ ->
                                           ((Some
                                               ((Obj.magic value : string)))
                                           [@explicit_arity ])
                                       | None -> None)))))
                         [@explicit_arity ])
                     | None -> None);
                  nullableOfNonNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value)
                         \\"nullableOfNonNullable\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (((Obj.magic value) |>
                                 (Js.Array.map
                                    (fun value -> (Obj.magic value : string))))))
                         [@explicit_arity ])
                     | None -> None);
                  nonNullableOfNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value)
                         \\"nonNullableOfNullable\\" in
                     (Obj.magic value) |>
                       (Js.Array.map
                          (fun value ->
                             match Js.toOption
                                     (Obj.magic value : 'a Js.Nullable.t)
                             with
                             | Some _ -> ((Some ((Obj.magic value : string)))
                                 [@explicit_arity ])
                             | None -> None)));
                  nonNullableOfNonNullable =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value)
                         \\"nonNullableOfNonNullable\\" in
                     (Obj.magic value) |>
                       (Js.Array.map
                          (fun value -> (Obj.magic value : string))))
                } : t_lists))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records listsArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      listsInput: string }
    type t_variables =
      {
      nullableOfNullable: string option array option ;
      nullableOfNonNullable: string array option ;
      nonNullableOfNullable: string option array ;
      nonNullableOfNonNullable: string array }
    let parse =
      (fun value ->
         ({
            listsInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"listsInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableOfNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    match a with
                                                    | None -> None
                                                    | ((Some
                                                        (b))[@explicit_arity
                                                              ])
                                                        ->
                                                        ((fun a ->
                                                            ((Some
                                                                ((Js.Json.string
                                                                    a)))
                                                            [@explicit_arity
                                                              ]))) b) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b)) inp.nullableOfNullable));
             (\\"nullableOfNonNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    ((Some
                                                        ((Js.Json.string a)))
                                                    [@explicit_arity ])) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b))
                  inp.nullableOfNonNullable));(\\"nonNullableOfNullable\\",
                                                (((fun a ->
                                                     ((Some
                                                         (((a |>
                                                              (Array.map
                                                                 (fun b ->
                                                                    match 
                                                                    (fun a ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ]))) b) b
                                                                    with
                                                                    | 
                                                                    ((Some
                                                                    (c))
                                                                    [@explicit_arity
                                                                    ]) -> c
                                                                    | 
                                                                    None ->
                                                                    Js.Json.null)))
                                                             |> Js.Json.array)))
                                                     [@explicit_arity ])))
                                                   inp.nonNullableOfNullable));
             (\\"nonNullableOfNonNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            ((Some ((Js.Json.string a)))
                                            [@explicit_arity ])) b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) inp.nonNullableOfNonNullable))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?nullableOfNullable  ?nullableOfNonNullable 
      ~nonNullableOfNullable  ~nonNullableOfNonNullable  () =
      f
        (serializeVariables
           ({
              nullableOfNullable;
              nullableOfNonNullable;
              nonNullableOfNullable;
              nonNullableOfNonNullable
            } : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records listsInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      listsInput: string }
    type t_variables = {
      arg: t_variables_ListsInput }
    and t_variables_ListsInput =
      {
      nullableOfNullable: string option array option ;
      nullableOfNonNullable: string array option ;
      nonNullableOfNullable: string option array ;
      nonNullableOfNonNullable: string array }
    let parse =
      (fun value ->
         ({
            listsInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"listsInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a -> ((Some ((serializeInputObjectListsInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectListsInput :
      t_variables_ListsInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableOfNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    match a with
                                                    | None -> None
                                                    | ((Some
                                                        (b))[@explicit_arity
                                                              ])
                                                        ->
                                                        ((fun a ->
                                                            ((Some
                                                                ((Js.Json.string
                                                                    a)))
                                                            [@explicit_arity
                                                              ]))) b) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b)) inp.nullableOfNullable));
             (\\"nullableOfNonNullable\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some
                                (((a |>
                                     (Array.map
                                        (fun b ->
                                           match (fun a ->
                                                    ((Some
                                                        ((Js.Json.string a)))
                                                    [@explicit_arity ])) b
                                           with
                                           | ((Some (c))[@explicit_arity ])
                                               -> c
                                           | None -> Js.Json.null)))
                                    |> Js.Json.array)))
                            [@explicit_arity ]))) b))
                  inp.nullableOfNonNullable));(\\"nonNullableOfNullable\\",
                                                (((fun a ->
                                                     ((Some
                                                         (((a |>
                                                              (Array.map
                                                                 (fun b ->
                                                                    match 
                                                                    (fun a ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ]))) b) b
                                                                    with
                                                                    | 
                                                                    ((Some
                                                                    (c))
                                                                    [@explicit_arity
                                                                    ]) -> c
                                                                    | 
                                                                    None ->
                                                                    Js.Json.null)))
                                                             |> Js.Json.array)))
                                                     [@explicit_arity ])))
                                                   inp.nonNullableOfNullable));
             (\\"nonNullableOfNonNullable\\",
               (((fun a ->
                    ((Some
                        (((a |>
                             (Array.map
                                (fun b ->
                                   match (fun a ->
                                            ((Some ((Js.Json.string a)))
                                            [@explicit_arity ])) b
                                   with
                                   | ((Some (c))[@explicit_arity ]) -> c
                                   | None -> Js.Json.null)))
                            |> Js.Json.array)))
                    [@explicit_arity ]))) inp.nonNullableOfNonNullable))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectListsInput ?nullableOfNullable  ?nullableOfNonNullable
       ~nonNullableOfNullable  ~nonNullableOfNonNullable  () =
      ({
         nullableOfNullable;
         nullableOfNonNullable;
         nonNullableOfNullable;
         nonNullableOfNonNullable
       } : t_variables_ListsInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records mutation.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      mutationWithError: t_mutationWithError }
    and t_mutationWithError =
      {
      value: t_mutationWithError_value option ;
      errors: t_mutationWithError_errors array option }
    and t_mutationWithError_errors =
      {
      field: [ \`FIRST  | \`SECOND  | \`THIRD ] ;
      message: string }
    and t_mutationWithError_value = {
      stringField: string }
    let parse =
      (fun value ->
         ({
            mutationWithError =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"mutationWithError\\" in
               ({
                  value =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"value\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (({
                                 stringField =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"stringField\\" in
                                    (Obj.magic value : string))
                               } : t_mutationWithError_value)))
                         [@explicit_arity ])
                     | None -> None);
                  errors =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"errors\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (((Obj.magic value) |>
                                 (Js.Array.map
                                    (fun value ->
                                       ({
                                          field =
                                            (let value =
                                               Js.Dict.unsafeGet
                                                 (Obj.magic value) \\"field\\" in
                                             match Js.Json.decodeString value
                                             with
                                             | None ->
                                                 Js.Exn.raiseError
                                                   (\\"graphql_ppx: \\" ^
                                                      (\\"Expected enum value for \\"
                                                         ^
                                                         (\\"SampleField\\" ^
                                                            (\\", got \\" ^
                                                               (Js.Json.stringify
                                                                  value)))))
                                             | ((Some
                                                 (value))[@explicit_arity ])
                                                 ->
                                                 ((match value with
                                                   | \\"FIRST\\" -> \`FIRST
                                                   | \\"SECOND\\" -> \`SECOND
                                                   | \\"THIRD\\" -> \`THIRD
                                                   | _ ->
                                                       Js.Exn.raiseError
                                                         (\\"graphql_ppx: \\" ^
                                                            (\\"Unknown enum variant for \\"
                                                               ^
                                                               (\\"SampleField\\"
                                                                  ^
                                                                  (\\": \\" ^
                                                                    value))))) : 
                                                 [ \`FIRST  | \`SECOND 
                                                 | \`THIRD ]));
                                          message =
                                            (let value =
                                               Js.Dict.unsafeGet
                                                 (Obj.magic value) \\"message\\" in
                                             (Obj.magic value : string))
                                        } : t_mutationWithError_errors))))))
                         [@explicit_arity ])
                     | None -> None)
                } : t_mutationWithError))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records mutationWithArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      optionalInputArgs: string }
    type t_variables = {
      required: string }
    let parse =
      (fun value ->
         ({
            optionalInputArgs =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"optionalInputArgs\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"required\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.required))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~required  () =
      f (serializeVariables ({ required } : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records nested.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
type record = {
  f1: string ;
  f2: string }
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      first: t_first ;
      second: t_second }
    and t_second = {
      inner: t_second_inner option }
    and t_second_inner = {
      inner: t_second_inner_inner option }
    and t_second_inner_inner = {
      f1: string ;
      f2: string }
    and t_first = {
      inner: t_first_inner option }
    and t_first_inner = {
      inner: t_first_inner_inner option }
    and t_first_inner_inner = {
      field: string }
    let parse =
      (fun value ->
         ({
            first =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"first\\" in
               ({
                  inner =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (({
                                 inner =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"inner\\" in
                                    (match Js.toOption
                                             (Obj.magic value : 'a
                                                                  Js.Nullable.t)
                                     with
                                     | Some _ ->
                                         ((Some
                                             (({
                                                 field =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"field\\" in
                                                    (Obj.magic value : 
                                                      string))
                                               } : t_first_inner_inner)))
                                         [@explicit_arity ])
                                     | None -> None))
                               } : t_first_inner)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_first));
            second =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"second\\" in
               ({
                  inner =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (({
                                 inner =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"inner\\" in
                                    (match Js.toOption
                                             (Obj.magic value : 'a
                                                                  Js.Nullable.t)
                                     with
                                     | Some _ ->
                                         ((Some
                                             (({
                                                 f1 =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"f1\\" in
                                                    (Obj.magic value : 
                                                      string));
                                                 f2 =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"f2\\" in
                                                    (Obj.magic value : 
                                                      string))
                                               } : t_second_inner_inner)))
                                         [@explicit_arity ])
                                     | None -> None))
                               } : t_second_inner)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_second))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records nonrecursiveInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      nonrecursiveInput: string }
    type t_variables = {
      arg: t_variables_NonrecursiveInput }
    and t_variables_NonrecursiveInput =
      {
      field: string option ;
      enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option }
    let parse =
      (fun value ->
         ({
            nonrecursiveInput =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"nonrecursiveInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectNonrecursiveInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectNonrecursiveInput :
      t_variables_NonrecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"field\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.field));(\\"enum\\",
                                                                    (
                                                                    ((fun a
                                                                    ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((match a
                                                                    with
                                                                    | \`FIRST
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"FIRST\\"
                                                                    | \`SECOND
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"SECOND\\"
                                                                    | \`THIRD
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"THIRD\\")))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    inp.enum))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectNonrecursiveInput ?field  ?enum  () =
      ({ field; enum } : t_variables_NonrecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records pokedexApolloMode.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      pokemon: t_pokemon option }
    and t_pokemon = {
      id: string ;
      name: string option }
    let parse =
      (fun value ->
         ({
            pokemon =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"pokemon\\" in
               match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
               | Some _ ->
                   ((Some
                       (({
                           id =
                             (let value =
                                Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                              (Obj.magic value : string));
                           name =
                             (let value =
                                Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                              (match Js.toOption
                                       (Obj.magic value : 'a Js.Nullable.t)
                               with
                               | Some _ ->
                                   ((Some ((Obj.magic value : string)))
                                   [@explicit_arity ])
                               | None -> None))
                         } : t_pokemon)))
                   [@explicit_arity ])
               | None -> None)
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records pokedexScalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      pokemon: t_pokemon option }
    and t_pokemon = {
      id: string ;
      name: string option }
    type t_variables = {
      id: string option ;
      name: string option }
    let parse =
      (fun value ->
         ({
            pokemon =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"pokemon\\" in
               match Js.toOption (Obj.magic value : 'a Js.Nullable.t) with
               | Some _ ->
                   ((Some
                       (({
                           id =
                             (let value =
                                Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                              (Obj.magic value : string));
                           name =
                             (let value =
                                Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                              (match Js.toOption
                                       (Obj.magic value : 'a Js.Nullable.t)
                               with
                               | Some _ ->
                                   ((Some ((Obj.magic value : string)))
                                   [@explicit_arity ])
                               | None -> None))
                         } : t_pokemon)))
                   [@explicit_arity ])
               | None -> None)
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"id\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.id));(\\"name\\",
                                                                 (((fun a ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((Js.Json.string
                                                                    a)))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    inp.name))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?id  ?name  () =
      f (serializeVariables ({ id; name } : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records record.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
type scalars = {
  string: string ;
  int: int }
type dog = {
  name: string ;
  barkVolume: float }
type oneFieldQuery = {
  nullableString: string option }
module MyQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      variousScalars: t_variousScalars }
    and t_variousScalars = {
      string: string ;
      int: int }
    let parse =
      (fun value ->
         ({
            variousScalars =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
               ({
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     (Obj.magic value : string));
                  int =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                     (Obj.magic value : int))
                } : t_variousScalars))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module OneFieldQuery =
  struct
    let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      variousScalars: t_variousScalars }
    and t_variousScalars = {
      nullableString: string option }
    let parse =
      (fun value ->
         ({
            variousScalars =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
               ({
                  nullableString =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_variousScalars))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module ExternalFragmentQuery =
  struct
    module Fragment =
      struct
        let query =
          \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\"
        type t = {
          string: string ;
          int: int }
        type raw_t
        type t_VariousScalars = t
        let parse (value : Js.Json.t) =
          ({
             string =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                (Obj.magic value : string));
             int =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                (Obj.magic value : int))
           } : t)
        let name = \\"Fragment\\"
      end
    module Untitled1 =
      struct
        let query =
          ((\\"query   {\\\\nvariousScalars  {\\\\n...\\" ^ Fragment.name) ^
             \\"   \\\\n}\\\\n\\\\n}\\\\n\\")
            ^ Fragment.query
        type raw_t
        type t = {
          variousScalars: Fragment.t }
        let parse =
          (fun value ->
             ({
                variousScalars =
                  (let value =
                     Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
                   Fragment.parse value)
              } : t) : Js.Json.t -> t)
        let makeVar ~f  () = f Js.Json.null
        let definition = (parse, query, makeVar)
      end
  end
module InlineFragmentQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      dogOrHuman: [ \`Nonexhaustive  | \`Dog of t_dogOrHuman_Dog ] }
    and t_dogOrHuman_Dog = {
      name: string ;
      barkVolume: float }
    let parse =
      (fun value ->
         ({
            dogOrHuman =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
               match Js.Json.decodeObject value with
               | None ->
                   Js.Exn.raiseError
                     (\\"graphql_ppx: \\" ^
                        (\\"Expected union \\" ^
                           (\\"DogOrHuman\\" ^
                              (\\" to be an object, got \\" ^
                                 (Js.Json.stringify value)))))
               | ((Some (typename_obj))[@explicit_arity ]) ->
                   (match Js.Dict.get typename_obj \\"__typename\\" with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Union \\" ^
                                (\\"DogOrHuman\\" ^
                                   \\" is missing the __typename field\\")))
                    | ((Some (typename))[@explicit_arity ]) ->
                        (match Js.Json.decodeString typename with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" has a __typename field that is not a string\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             ((match typename with
                               | \\"Dog\\" ->
                                   \`Dog
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string));
                                        barkVolume =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"barkVolume\\" in
                                           (Obj.magic value : float))
                                      } : t_dogOrHuman_Dog)
                               | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                        | \`Dog of _ ]))))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end
module UnionExternalFragmentQuery =
  struct
    module DogFragment =
      struct
        let query =
          \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\"
        type t = {
          name: string ;
          barkVolume: float }
        type raw_t
        type t_Dog = t
        let parse (value : Js.Json.t) =
          ({
             name =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"name\\" in
                (Obj.magic value : string));
             barkVolume =
               (let value = Js.Dict.unsafeGet (Obj.magic value) \\"barkVolume\\" in
                (Obj.magic value : float))
           } : t)
        let name = \\"DogFragment\\"
      end
    module Untitled1 =
      struct
        let query =
          ((\\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\" ^
              DogFragment.name)
             ^ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\")
            ^ DogFragment.query
        type raw_t
        type t = {
          dogOrHuman: [ \`Nonexhaustive  | \`Dog of DogFragment.t ] }
        let parse =
          (fun value ->
             ({
                dogOrHuman =
                  (let value =
                     Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
                   match Js.Json.decodeObject value with
                   | None ->
                       Js.Exn.raiseError
                         (\\"graphql_ppx: \\" ^
                            (\\"Expected union \\" ^
                               (\\"DogOrHuman\\" ^
                                  (\\" to be an object, got \\" ^
                                     (Js.Json.stringify value)))))
                   | ((Some (typename_obj))[@explicit_arity ]) ->
                       (match Js.Dict.get typename_obj \\"__typename\\" with
                        | None ->
                            Js.Exn.raiseError
                              (\\"graphql_ppx: \\" ^
                                 (\\"Union \\" ^
                                    (\\"DogOrHuman\\" ^
                                       \\" is missing the __typename field\\")))
                        | ((Some (typename))[@explicit_arity ]) ->
                            (match Js.Json.decodeString typename with
                             | None ->
                                 Js.Exn.raiseError
                                   (\\"graphql_ppx: \\" ^
                                      (\\"Union \\" ^
                                         (\\"DogOrHuman\\" ^
                                            \\" has a __typename field that is not a string\\")))
                             | ((Some (typename))[@explicit_arity ]) ->
                                 ((match typename with
                                   | \\"Dog\\" -> \`Dog (DogFragment.parse value)
                                   | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                            | \`Dog of _ ]))))
              } : t) : Js.Json.t -> t)
        let makeVar ~f  () = f Js.Json.null
        let definition = (parse, query, makeVar)
      end
  end"
`;

exports[`Records recursiveInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      recursiveInput: string }
    type t_variables = {
      arg: t_variables_RecursiveInput }
    and t_variables_RecursiveInput =
      {
      otherField: string option ;
      inner: t_variables_RecursiveInput option ;
      enum: [ \`FIRST  | \`SECOND  | \`THIRD ] option }
    let parse =
      (fun value ->
         ({
            recursiveInput =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"recursiveInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a -> ((Some ((serializeInputObjectRecursiveInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectRecursiveInput :
      t_variables_RecursiveInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"otherField\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.otherField));
             (\\"inner\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a ->
                            ((Some ((serializeInputObjectRecursiveInput a)))
                            [@explicit_arity ]))) b)) inp.inner));(\\"enum\\",
                                                                    (
                                                                    ((fun a
                                                                    ->
                                                                    match a
                                                                    with
                                                                    | 
                                                                    None ->
                                                                    None
                                                                    | 
                                                                    ((Some
                                                                    (b))
                                                                    [@explicit_arity
                                                                    ]) ->
                                                                    ((fun a
                                                                    ->
                                                                    ((Some
                                                                    ((match a
                                                                    with
                                                                    | \`FIRST
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"FIRST\\"
                                                                    | \`SECOND
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"SECOND\\"
                                                                    | \`THIRD
                                                                    ->
                                                                    Js.Json.string
                                                                    \\"THIRD\\")))
                                                                    [@explicit_arity
                                                                    ]))) b))
                                                                    inp.enum))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectRecursiveInput ?otherField  ?inner  ?enum  () =
      ({ otherField; inner; enum } : t_variables_RecursiveInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records scalars.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      variousScalars: t_variousScalars }
    and t_variousScalars =
      {
      nullableString: string option ;
      string: string ;
      nullableInt: int option ;
      int: int ;
      nullableFloat: float option ;
      float: float ;
      nullableBoolean: bool option ;
      boolean: bool ;
      nullableID: string option ;
      id: string }
    let parse =
      (fun value ->
         ({
            variousScalars =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"variousScalars\\" in
               ({
                  nullableString =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None);
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     (Obj.magic value : string));
                  nullableInt =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableInt\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : int)))
                         [@explicit_arity ])
                     | None -> None);
                  int =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"int\\" in
                     (Obj.magic value : int));
                  nullableFloat =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableFloat\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : float)))
                         [@explicit_arity ])
                     | None -> None);
                  float =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"float\\" in
                     (Obj.magic value : float));
                  nullableBoolean =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableBoolean\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : bool)))
                         [@explicit_arity ])
                     | None -> None);
                  boolean =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"boolean\\" in
                     (Obj.magic value : bool));
                  nullableID =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableID\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None);
                  id =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"id\\" in
                     (Obj.magic value : string))
                } : t_variousScalars))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records scalarsArgs.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      scalarsInput: string }
    type t_variables =
      {
      nullableString: string option ;
      string: string ;
      nullableInt: int option ;
      int: int ;
      nullableFloat: float option ;
      float: float ;
      nullableBoolean: bool option ;
      boolean: bool ;
      nullableID: string option ;
      id: string }
    let parse =
      (fun value ->
         ({
            scalarsInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"scalarsInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableString\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.nullableString));
             (\\"string\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.string));(\\"nullableInt\\",
                                 (((fun a ->
                                      match a with
                                      | None -> None
                                      | ((Some (b))[@explicit_arity ]) ->
                                          ((fun a ->
                                              ((Some
                                                  ((Js.Json.number
                                                      (float_of_int a))))
                                              [@explicit_arity ]))) b))
                                    inp.nullableInt));(\\"int\\",
                                                        (((fun a ->
                                                             ((Some
                                                                 ((Js.Json.number
                                                                    (float_of_int
                                                                    a))))
                                                             [@explicit_arity
                                                               ]))) inp.int));
             (\\"nullableFloat\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.number a)))
                            [@explicit_arity ]))) b)) inp.nullableFloat));
             (\\"float\\",
               (((fun a -> ((Some ((Js.Json.number a)))[@explicit_arity ])))
                  inp.float));(\\"nullableBoolean\\",
                                (((fun a ->
                                     match a with
                                     | None -> None
                                     | ((Some (b))[@explicit_arity ]) ->
                                         ((fun a ->
                                             ((Some ((Js.Json.boolean a)))
                                             [@explicit_arity ]))) b))
                                   inp.nullableBoolean));(\\"boolean\\",
                                                           (((fun a ->
                                                                ((Some
                                                                    ((Js.Json.boolean
                                                                    a)))
                                                                [@explicit_arity
                                                                  ])))
                                                              inp.boolean));
             (\\"nullableID\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.nullableID));
             (\\"id\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.id))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ?nullableString  ~string  ?nullableInt  ~int 
      ?nullableFloat  ~float  ?nullableBoolean  ~boolean  ?nullableID  ~id 
      () =
      f
        (serializeVariables
           ({
              nullableString;
              string;
              nullableInt;
              int;
              nullableFloat;
              float;
              nullableBoolean;
              boolean;
              nullableID;
              id
            } : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records scalarsInput.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\"
    type raw_t
    type t = {
      scalarsInput: string }
    type t_variables = {
      arg: t_variables_VariousScalarsInput }
    and t_variables_VariousScalarsInput =
      {
      nullableString: string option ;
      string: string ;
      nullableInt: int option ;
      int: int ;
      nullableFloat: float option ;
      float: float ;
      nullableBoolean: bool option ;
      boolean: bool ;
      nullableID: string option ;
      id: string }
    let parse =
      (fun value ->
         ({
            scalarsInput =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"scalarsInput\\" in
               (Obj.magic value : string))
          } : t) : Js.Json.t -> t)
    let rec (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"arg\\",
               (((fun a ->
                    ((Some ((serializeInputObjectVariousScalarsInput a)))
                    [@explicit_arity ]))) inp.arg))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    and (serializeInputObjectVariousScalarsInput :
      t_variables_VariousScalarsInput -> Js.Json.t) =
      fun inp ->
        ((([|(\\"nullableString\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.nullableString));
             (\\"string\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.string));(\\"nullableInt\\",
                                 (((fun a ->
                                      match a with
                                      | None -> None
                                      | ((Some (b))[@explicit_arity ]) ->
                                          ((fun a ->
                                              ((Some
                                                  ((Js.Json.number
                                                      (float_of_int a))))
                                              [@explicit_arity ]))) b))
                                    inp.nullableInt));(\\"int\\",
                                                        (((fun a ->
                                                             ((Some
                                                                 ((Js.Json.number
                                                                    (float_of_int
                                                                    a))))
                                                             [@explicit_arity
                                                               ]))) inp.int));
             (\\"nullableFloat\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.number a)))
                            [@explicit_arity ]))) b)) inp.nullableFloat));
             (\\"float\\",
               (((fun a -> ((Some ((Js.Json.number a)))[@explicit_arity ])))
                  inp.float));(\\"nullableBoolean\\",
                                (((fun a ->
                                     match a with
                                     | None -> None
                                     | ((Some (b))[@explicit_arity ]) ->
                                         ((fun a ->
                                             ((Some ((Js.Json.boolean a)))
                                             [@explicit_arity ]))) b))
                                   inp.nullableBoolean));(\\"boolean\\",
                                                           (((fun a ->
                                                                ((Some
                                                                    ((Js.Json.boolean
                                                                    a)))
                                                                [@explicit_arity
                                                                  ])))
                                                              inp.boolean));
             (\\"nullableID\\",
               (((fun a ->
                    match a with
                    | None -> None
                    | ((Some (b))[@explicit_arity ]) ->
                        ((fun a -> ((Some ((Js.Json.string a)))
                            [@explicit_arity ]))) b)) inp.nullableID));
             (\\"id\\",
               (((fun a -> ((Some ((Js.Json.string a)))[@explicit_arity ])))
                  inp.id))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~arg  () = f (serializeVariables ({ arg } : t_variables))
    and makeInputObjectVariousScalarsInput ?nullableString  ~string 
      ?nullableInt  ~int  ?nullableFloat  ~float  ?nullableBoolean  ~boolean 
      ?nullableID  ~id  () =
      ({
         nullableString;
         string;
         nullableInt;
         int;
         nullableFloat;
         float;
         nullableBoolean;
         boolean;
         nullableID;
         id
       } : t_variables_VariousScalarsInput)
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records skipDirectives.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      v1: t_v1 ;
      v2: t_v2 }
    and t_v2 = {
      nullableString: string option ;
      string: string option }
    and t_v1 = {
      nullableString: string option ;
      string: string option }
    type t_variables = {
      var: bool }
    let parse =
      (fun value ->
         ({
            v1 =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"v1\\" in
               ({
                  nullableString =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None);
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_v1));
            v2 =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"v2\\" in
               ({
                  nullableString =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"nullableString\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None);
                  string =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"string\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ -> ((Some ((Obj.magic value : string)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_v2))
          } : t) : Js.Json.t -> t)
    let (serializeVariables : t_variables -> Js.Json.t) =
      fun inp ->
        ((([|(\\"var\\",
               (((fun a -> ((Some ((Js.Json.boolean a)))[@explicit_arity ])))
                  inp.var))|]
             |>
             (Js.Array.filter
                (function | (_, None) -> false | (_, Some _) -> true)))
            |>
            (Js.Array.map
               (function
                | (k, ((Some (v))[@explicit_arity ])) -> (k, v)
                | (k, None) -> (k, Js.Json.null))))
           |> Js.Dict.fromArray)
          |> Js.Json.object_
    let makeVar ~f  ~var  () = f (serializeVariables ({ var } : t_variables))
    let definition = (parse, query, makeVar)
    let makeVariables = makeVar ~f:(fun f -> f)
  end"
`;

exports[`Records subscription.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      {
      simpleSubscription:
        [ \`Dog of t_simpleSubscription_Dog 
        | \`Human of t_simpleSubscription_Human ] }
    and t_simpleSubscription_Human = {
      name: string }
    and t_simpleSubscription_Dog = {
      name: string }
    let parse =
      (fun value ->
         ({
            simpleSubscription =
              (let value =
                 Js.Dict.unsafeGet (Obj.magic value) \\"simpleSubscription\\" in
               match Js.Json.decodeObject value with
               | None ->
                   Js.Exn.raiseError
                     (\\"graphql_ppx: \\" ^
                        (\\"Expected union \\" ^
                           (\\"DogOrHuman\\" ^
                              (\\" to be an object, got \\" ^
                                 (Js.Json.stringify value)))))
               | ((Some (typename_obj))[@explicit_arity ]) ->
                   (match Js.Dict.get typename_obj \\"__typename\\" with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Union \\" ^
                                (\\"DogOrHuman\\" ^
                                   \\" is missing the __typename field\\")))
                    | ((Some (typename))[@explicit_arity ]) ->
                        (match Js.Json.decodeString typename with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" has a __typename field that is not a string\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             ((match typename with
                               | \\"Dog\\" ->
                                   \`Dog
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string))
                                      } : t_simpleSubscription_Dog)
                               | \\"Human\\" ->
                                   \`Human
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string))
                                      } : t_simpleSubscription_Human)
                               | typename ->
                                   Js.Exn.raiseError
                                     (\\"graphql_ppx: \\" ^
                                        (\\"Union \\" ^
                                           (\\"DogOrHuman\\" ^
                                              (\\" returned unknown type \\" ^
                                                 typename))))) : [ \`Dog of _ 
                                                                 | \`Human of
                                                                    _ ]))))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records typename.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      first: t_first }
    and t_first = {
      __typename: string ;
      inner: t_first_inner option }
    and t_first_inner =
      {
      __typename: string ;
      inner: t_first_inner_inner option }
    and t_first_inner_inner = {
      __typename: string ;
      field: string }
    let parse =
      (fun value ->
         ({
            first =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"first\\" in
               ({
                  __typename =
                    (let value =
                       Js.Dict.unsafeGet (Obj.magic value) \\"__typename\\" in
                     (Obj.magic value : string));
                  inner =
                    (let value = Js.Dict.unsafeGet (Obj.magic value) \\"inner\\" in
                     match Js.toOption (Obj.magic value : 'a Js.Nullable.t)
                     with
                     | Some _ ->
                         ((Some
                             (({
                                 __typename =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"__typename\\" in
                                    (Obj.magic value : string));
                                 inner =
                                   (let value =
                                      Js.Dict.unsafeGet (Obj.magic value)
                                        \\"inner\\" in
                                    (match Js.toOption
                                             (Obj.magic value : 'a
                                                                  Js.Nullable.t)
                                     with
                                     | Some _ ->
                                         ((Some
                                             (({
                                                 __typename =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"__typename\\" in
                                                    (Obj.magic value : 
                                                      string));
                                                 field =
                                                   (let value =
                                                      Js.Dict.unsafeGet
                                                        (Obj.magic value)
                                                        \\"field\\" in
                                                    (Obj.magic value : 
                                                      string))
                                               } : t_first_inner_inner)))
                                         [@explicit_arity ])
                                     | None -> None))
                               } : t_first_inner)))
                         [@explicit_arity ])
                     | None -> None)
                } : t_first))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records union.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t =
      {
      dogOrHuman:
        [ \`Dog of t_dogOrHuman_Dog  | \`Human of t_dogOrHuman_Human ] }
    and t_dogOrHuman_Human = {
      name: string }
    and t_dogOrHuman_Dog = {
      name: string ;
      barkVolume: float }
    let parse =
      (fun value ->
         ({
            dogOrHuman =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
               match Js.Json.decodeObject value with
               | None ->
                   Js.Exn.raiseError
                     (\\"graphql_ppx: \\" ^
                        (\\"Expected union \\" ^
                           (\\"DogOrHuman\\" ^
                              (\\" to be an object, got \\" ^
                                 (Js.Json.stringify value)))))
               | ((Some (typename_obj))[@explicit_arity ]) ->
                   (match Js.Dict.get typename_obj \\"__typename\\" with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Union \\" ^
                                (\\"DogOrHuman\\" ^
                                   \\" is missing the __typename field\\")))
                    | ((Some (typename))[@explicit_arity ]) ->
                        (match Js.Json.decodeString typename with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" has a __typename field that is not a string\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             ((match typename with
                               | \\"Dog\\" ->
                                   \`Dog
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string));
                                        barkVolume =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"barkVolume\\" in
                                           (Obj.magic value : float))
                                      } : t_dogOrHuman_Dog)
                               | \\"Human\\" ->
                                   \`Human
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string))
                                      } : t_dogOrHuman_Human)
                               | typename ->
                                   Js.Exn.raiseError
                                     (\\"graphql_ppx: \\" ^
                                        (\\"Union \\" ^
                                           (\\"DogOrHuman\\" ^
                                              (\\" returned unknown type \\" ^
                                                 typename))))) : [ \`Dog of _ 
                                                                 | \`Human of
                                                                    _ ]))))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;

exports[`Records unionPartial.re 1`] = `
"[@@@ocaml.ppx.context { cookies = [] }]
module MyQuery =
  struct
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
    type raw_t
    type t = {
      dogOrHuman: [ \`Nonexhaustive  | \`Dog of t_dogOrHuman_Dog ] }
    and t_dogOrHuman_Dog = {
      name: string ;
      barkVolume: float }
    let parse =
      (fun value ->
         ({
            dogOrHuman =
              (let value = Js.Dict.unsafeGet (Obj.magic value) \\"dogOrHuman\\" in
               match Js.Json.decodeObject value with
               | None ->
                   Js.Exn.raiseError
                     (\\"graphql_ppx: \\" ^
                        (\\"Expected union \\" ^
                           (\\"DogOrHuman\\" ^
                              (\\" to be an object, got \\" ^
                                 (Js.Json.stringify value)))))
               | ((Some (typename_obj))[@explicit_arity ]) ->
                   (match Js.Dict.get typename_obj \\"__typename\\" with
                    | None ->
                        Js.Exn.raiseError
                          (\\"graphql_ppx: \\" ^
                             (\\"Union \\" ^
                                (\\"DogOrHuman\\" ^
                                   \\" is missing the __typename field\\")))
                    | ((Some (typename))[@explicit_arity ]) ->
                        (match Js.Json.decodeString typename with
                         | None ->
                             Js.Exn.raiseError
                               (\\"graphql_ppx: \\" ^
                                  (\\"Union \\" ^
                                     (\\"DogOrHuman\\" ^
                                        \\" has a __typename field that is not a string\\")))
                         | ((Some (typename))[@explicit_arity ]) ->
                             ((match typename with
                               | \\"Dog\\" ->
                                   \`Dog
                                     ({
                                        name =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"name\\" in
                                           (Obj.magic value : string));
                                        barkVolume =
                                          (let value =
                                             Js.Dict.unsafeGet
                                               (Obj.magic value) \\"barkVolume\\" in
                                           (Obj.magic value : float))
                                      } : t_dogOrHuman_Dog)
                               | _ -> \`Nonexhaustive) : [ \`Nonexhaustive 
                                                        | \`Dog of _ ]))))
          } : t) : Js.Json.t -> t)
    let makeVar ~f  () = f Js.Json.null
    let definition = (parse, query, makeVar)
  end"
`;
